"""Зависимости FastAPI для аутентификации и авторизации.Содержит dependency функции для получения текущего пользователя,проверки прав доступа и создания гостевых сессий.Обеспечивает безопасность API endpoints."""import loggingimport uuidfrom datetime import datetimefrom typing import Optionalfrom fastapi import Depends, HTTPException, status, Requestfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.core.db import get_dbfrom app.core.auth import auth_handlerfrom app.models.models import Userfrom app.schemas.user import GuestUserCreatelogger = logging.getLogger(__name__)# HTTP Bearer схема для извлечения токенов из заголовковsecurity = HTTPBearer(auto_error=False)async def get_current_user_from_token(    credentials: HTTPAuthorizationCredentials = Depends(security),    db: AsyncSession = Depends(get_db)) -> User:    """    Получение текущего пользователя из JWT токена.    Извлекает и валидирует JWT токен из заголовка Authorization,    декодирует его и возвращает соответствующего пользователя из базы данных.    Args:        credentials: HTTP Bearer учетные данные        db: Сессия базы данных    Returns:        User: Аутентифицированный пользователь    Raises:        HTTPException: При отсутствии токена, невалидном токене или неактивном пользователе    """    if not credentials:        logger.warning("No authorization credentials provided")        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authorization header is required",            headers={"WWW-Authenticate": "Bearer"},        )    try:        # Декодируем токен и извлекаем payload        payload = auth_handler.decode_token(credentials.credentials)        # Проверяем тип токена        if not auth_handler.validate_token_type(payload, "access"):            logger.warning("Invalid token type provided")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token type",                headers={"WWW-Authenticate": "Bearer"},            )        # Извлекаем user_id из токена        user_id_str = auth_handler.get_token_subject(payload)        if not user_id_str:            logger.warning("Token missing user ID")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token format",                headers={"WWW-Authenticate": "Bearer"},            )        try:            user_id = int(user_id_str)        except ValueError:            logger.warning(f"Invalid user ID format in token: {user_id_str}")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token format",                headers={"WWW-Authenticate": "Bearer"},            )        # Получаем пользователя из базы данных        from app.crud.user import user_crud        user = await user_crud.get(db, obj_id=user_id)        if not user:            logger.warning(f"User {user_id} not found in database")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="User not found",                headers={"WWW-Authenticate": "Bearer"},            )        # Проверяем активность пользователя        if not user.is_active:            logger.warning(f"Inactive user {user_id} attempted to access API")            raise HTTPException(                status_code=status.HTTP_403_FORBIDDEN,                detail="User account is inactive"            )        # Обновляем время последнего входа        try:            await user_crud.update_last_login(db, user_id=user_id)        except Exception as e:            # Не прерываем процесс аутентификации из-за ошибки обновления            logger.warning(f"Failed to update last login for user {user_id}: {e}")        logger.debug(f"User {user_id} authenticated successfully")        return user    except HTTPException:        # Переброс HTTPException без изменений        raise    except Exception as e:        logger.error(f"Unexpected error during authentication: {e}")        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authentication failed",            headers={"WWW-Authenticate": "Bearer"},        )async def get_current_registered_user(    current_user: User = Depends(get_current_user_from_token)) -> User:    """    Получение только зарегистрированного пользователя (не гостя).    Проверяет, что текущий пользователь является зарегистрированным,    а не гостевым. Используется для endpoints, требующих полной регистрации.    Args:        current_user: Текущий аутентифицированный пользователь    Returns:        User: Зарегистрированный пользователь    Raises:        HTTPException: Если пользователь является гостем    """    if current_user.is_guest:        logger.warning(f"Guest user {current_user.id} attempted to access registered-only endpoint")        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Access forbidden. Registration required."        )    return current_userasync def get_current_user_or_create_guest(  # ИСПРАВЛЕНО: правильное имя для совместимости с роутами    request: Request,    db: AsyncSession = Depends(get_db),    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)) -> User:    """    Получение пользователя или создание гостевого.    Если предоставлены валидные учетные данные - возвращает аутентифицированного пользователя.    В противном случае создает или возвращает гостевого пользователя на основе сессии.    Args:        request: HTTP запрос для получения сессии        db: Сессия базы данных        credentials: Опциональные учетные данные    Returns:        User: Аутентифицированный или гостевой пользователь    """    # Пытаемся аутентифицировать пользователя    if credentials:        try:            return await get_current_user_from_token(credentials, db)        except HTTPException:            # Игнорируем ошибки аутентификации и создаем гостя            logger.debug("Failed to authenticate user, creating guest session")    # Получаем session_id из заголовков или генерируем новый    session_id = request.headers.get("X-Session-ID")    if not session_id:        session_id = str(uuid.uuid4())    from app.crud.user import user_crud    # Пытаемся найти существующую гостевую сессию    guest_user = await user_crud.get_guest_by_session_id(db, session_id=session_id)    if guest_user and guest_user.guest_expires_at > datetime.now():        logger.debug(f"Found valid guest session: {session_id}")        return guest_user    elif guest_user:        # Гостевая сессия истекла, удаляем её        await user_crud.delete(db, obj_id=guest_user.id)        logger.debug(f"Removed expired guest session: {session_id}")    # Создаем нового гостевого пользователя    guest_data = GuestUserCreate(session_id=session_id)    guest_user = await user_crud.create_guest_user(db, obj_in=guest_data)    logger.info(f"Created new guest session: {session_id}")    return guest_user# ДОБАВЛЯЕМ АЛИАС ДЛЯ СОВМЕСТИМОСТИget_current_user_or_guest = get_current_user_or_create_guestasync def get_optional_current_user(    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),    db: AsyncSession = Depends(get_db)) -> Optional[User]:    """    Получение текущего пользователя (опционально).    Возвращает пользователя если токен предоставлен и валиден,    None в противном случае. Не вызывает исключений.    Args:        credentials: Опциональные учетные данные        db: Сессия базы данных    Returns:        Optional[User]: Пользователь или None    """    if not credentials:        return None    try:        return await get_current_user_from_token(credentials, db)    except HTTPException:        return None