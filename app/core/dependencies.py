import loggingimport uuidfrom typing import Optionalfrom fastapi import Depends, HTTPException, status, Cookie, Requestfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom jose import JWTError, jwtfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.core.config import settingsfrom app.core.db import get_dbfrom app.core.redis import get_redis, RedisClientfrom app.crud.user import user_crudfrom app.models.models import Userlogger = logging.getLogger(__name__)security = HTTPBearer(auto_error=False)class AuthenticationError(Exception):    """Кастомное исключение для ошибок аутентификации"""    passasync def _authenticate_user_by_token(        credentials: HTTPAuthorizationCredentials,        db: AsyncSession) -> Optional[User]:    """Вспомогательная функция для аутентификации по токену"""    try:        payload = jwt.decode(            credentials.credentials,            settings.secret_key,            algorithms=[settings.algorithm]        )        user_id: int = payload.get("sub")        if user_id:            user = await user_crud.get(db, id=user_id)            if user and user.is_active:                logger.info(f"User {user_id} authenticated successfully")                return user    except JWTError as e:        logger.warning(f"JWT decode error: {e}")    except Exception as e:        logger.error(f"Unexpected error during token authentication: {e}")    return Noneasync def _get_guest_user(        session_id: str,        db: AsyncSession) -> Optional[User]:    """Вспомогательная функция для получения гостевого пользователя"""    try:        user = await user_crud.get_by_session_id(db, session_id=session_id)        if user:            logger.info(f"Guest user found for session {session_id}")            return user    except Exception as e:        logger.error(f"Error getting guest user: {e}")    return Noneasync def get_current_user(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> Optional[User]:    """Получение текущего пользователя (зарегистрированного или гостевого)"""    # Попытка аутентификации по токену    if credentials:        user = await _authenticate_user_by_token(credentials, db)        if user:            return user    # Попытка получения гостевого пользователя    if session_id:        user = await _get_guest_user(session_id, db)        if user:            return user    return Noneasync def get_current_user_or_create_guest(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> User:    """Получение пользователя или создание гостевого если не найден"""    # Сначала пытаемся получить существующего пользователя    user = await get_current_user(db, credentials, session_id)    if user:        return user    # Если пользователь не найден, создаем гостевого    try:        new_session_id = session_id or str(uuid.uuid4())        guest_user = await user_crud.create_guest_user(db, session_id=new_session_id)        logger.info(f"Created new guest user with session {new_session_id}")        return guest_user    except Exception as e:        logger.error(f"Error creating guest user: {e}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail="Failed to create guest user"        )async def get_current_user_from_token(        credentials: HTTPAuthorizationCredentials = Depends(security),        db: AsyncSession = Depends(get_db)) -> User:    """Получение пользователя строго из JWT токена (для защищенных роутов)"""    if not credentials:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authentication required",            headers={"WWW-Authenticate": "Bearer"},        )    user = await _authenticate_user_by_token(credentials, db)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Invalid or expired token",            headers={"WWW-Authenticate": "Bearer"},        )    return userasync def get_current_active_user(        current_user: User = Depends(get_current_user)) -> User:    """Получение активного пользователя (обязательно)"""    if not current_user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authentication required"        )    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="User account is inactive"        )    return current_userasync def get_current_registered_user(        current_user: User = Depends(get_current_active_user)) -> User:    """Получение зарегистрированного пользователя"""    if current_user.is_guest:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Registration required for this action"        )    return current_userasync def get_current_registered_user_from_token(        current_user: User = Depends(get_current_user_from_token)) -> User:    """Получение зарегистрированного пользователя строго из токена"""    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="User account is inactive"        )    if current_user.is_guest:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Registration required for this action"        )    return current_userasync def get_optional_user(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> Optional[User]:    """Получение пользователя (опционально, без создания гостевого)"""    return await get_current_user(db, credentials, session_id)async def get_rate_limiter(        request: Request,        redis: RedisClient = Depends(get_redis)) -> bool:    """Rate limiting dependency с улучшенной логикой"""    # Получаем идентификатор из заголовка или IP    request_id = request.headers.get("X-Request-ID")    if not request_id:        # Используем IP адрес как fallback        client_ip = request.client.host if request.client else "unknown"        request_id = f"ip:{client_ip}"    try:        is_allowed = await redis.rate_limit_check(            identifier=request_id,            limit=settings.rate_limit_requests,            window_seconds=settings.rate_limit_window        )        if not is_allowed:            logger.warning(f"Rate limit exceeded for {request_id}")            raise HTTPException(                status_code=status.HTTP_429_TOO_MANY_REQUESTS,                detail="Rate limit exceeded. Please try again later."            )        return True    except HTTPException:        raise    except Exception as e:        logger.error(f"Rate limiting error: {e}")        # В случае ошибки Redis, пропускаем запрос        return True