"""Зависимости FastAPI для аутентификации и авторизации."""import loggingimport uuidfrom datetime import datetime, timezonefrom typing import Optionalfrom fastapi import Depends, HTTPException, status, Requestfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.core.auth import auth_handlerfrom app.core.db import get_dbfrom app.models.models import Userlogger = logging.getLogger(__name__)# HTTP Bearer схема для извлечения токенов из заголовковsecurity = HTTPBearer(auto_error=False)async def get_current_user_from_token(    credentials: HTTPAuthorizationCredentials = Depends(security),    db: AsyncSession = Depends(get_db)) -> User:    """    Получение текущего пользователя из JWT токена.    Извлекает и валидирует JWT токен из заголовка Authorization,    декодирует его и возвращает соответствующего пользователя из базы данных.    Args:        credentials: HTTP Bearer учетные данные        db: Сессия базы данных    Returns:        User: Аутентифицированный пользователь    Raises:        HTTPException: При отсутствии токена, невалидном токене или неактивном пользователе    """    if not credentials:        logger.warning("No authorization credentials provided")        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authorization header is required",            headers={"WWW-Authenticate": "Bearer"},        )    try:        # Декодируем токен и извлекаем payload        payload = auth_handler.decode_token(credentials.credentials)        logger.debug(f"Token decoded successfully for subject: {payload.get('sub')}")        # Проверяем тип токена        if not auth_handler.validate_token_type(payload, "access"):            logger.warning("Invalid token type provided")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token type",                headers={"WWW-Authenticate": "Bearer"},            )        # Извлекаем user_id из токена        user_id_str = auth_handler.get_token_subject(payload)        if not user_id_str:            logger.warning("Token missing user ID")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token format",                headers={"WWW-Authenticate": "Bearer"},            )        try:            user_id = int(user_id_str)        except ValueError:            logger.warning(f"Invalid user ID format in token: {user_id_str}")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Invalid token format",                headers={"WWW-Authenticate": "Bearer"},            )        # ИСПРАВЛЕНИЕ: Правильный вызов get() с параметром id        from app.crud.user import user_crud        user = await user_crud.get(db, id=user_id)        if not user:            logger.warning(f"User {user_id} not found in database")            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="User not found",                headers={"WWW-Authenticate": "Bearer"},            )        # Проверяем активность пользователя        if not user.is_active:            logger.warning(f"Inactive user {user_id} attempted to access API")            raise HTTPException(                status_code=status.HTTP_403_FORBIDDEN,                detail="User account is inactive"            )        # ИСПРАВЛЕНИЕ: Правильный вызов update_last_login        try:            await user_crud.update_last_login(db, user_id=user_id)        except Exception as e:            # Не прерываем процесс аутентификации из-за ошибки обновления            logger.warning(f"Failed to update last login for user {user_id}: {e}")        logger.debug(f"User {user_id} authenticated successfully")        return user    except HTTPException:        # Переброс HTTPException без изменений        raise    except Exception as e:        logger.error(f"Unexpected error during authentication: {e}")        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Authentication failed",            headers={"WWW-Authenticate": "Bearer"},        )async def get_current_registered_user(    current_user: User = Depends(get_current_user_from_token)) -> User:    """    Получение только зарегистрированного пользователя (не гостя).    Проверяет, что текущий пользователь является зарегистрированным,    а не гостевым. Используется для endpoints, требующих полной регистрации.    Args:        current_user: Текущий аутентифицированный пользователь    Returns:        User: Зарегистрированный пользователь    Raises:        HTTPException: Если пользователь является гостем    """    if current_user.is_guest:        logger.warning(f"Guest user {current_user.id} attempted to access registered-only endpoint")        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Access forbidden. Registration required."        )    return current_userasync def get_current_user_or_create_guest(    request: Request,    db: AsyncSession = Depends(get_db),    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)) -> User:    """    Получение пользователя или создание гостевого.    ИСПРАВЛЕНИЯ:    ✅ Правильные вызовы CRUD методов    ✅ Enhanced error handling    ✅ Better guest session management    Args:        request: HTTP запрос для получения сессии        db: Сессия базы данных        credentials: Опциональные учетные данные    Returns:        User: Аутентифицированный или гостевой пользователь    """    # Пытаемся аутентифицировать пользователя    if credentials:        try:            return await get_current_user_from_token(credentials, db)        except HTTPException:            # Игнорируем ошибки аутентификации и создаем гостя            logger.debug("Failed to authenticate user, creating guest session")    # Получаем session_id из заголовков или генерируем новый    session_id = request.headers.get("X-Session-ID")    if not session_id:        session_id = str(uuid.uuid4())    from app.crud.user import user_crud    # ИСПРАВЛЕНИЕ: Используем правильный метод для получения guest пользователя    guest_user = await user_crud.get_by_session_id(db, session_id=session_id)    current_time = datetime.now(timezone.utc)    # Проверяем существующую guest сессию    if guest_user:        # Проверяем не истекла ли сессия        if hasattr(guest_user, 'guest_expires_at') and guest_user.guest_expires_at:            if guest_user.guest_expires_at > current_time:                logger.debug(f"Found valid guest session: {session_id}")                return guest_user            else:                # Сессия истекла, удаляем её                # ИСПРАВЛЕНИЕ: Правильный вызов delete с параметром id                await user_crud.remove(db, id=guest_user.id)                logger.debug(f"Removed expired guest session: {session_id}")        else:            # Сессия без expiration - возвращаем            logger.debug(f"Found guest session without expiration: {session_id}")            return guest_user    # ИСПРАВЛЕНИЕ: Создаем нового гостевого пользователя правильным методом    guest_user = await user_crud.create_guest_user(db, session_id=session_id)    if guest_user:        logger.info(f"Created new guest session: {session_id}")        return guest_user    else:        logger.error(f"Failed to create guest user for session: {session_id}")        raise HTTPException(            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,            detail="Failed to create guest session"        )# ДОБАВЛЯЕМ АЛИАС ДЛЯ СОВМЕСТИМОСТИget_current_user_or_guest = get_current_user_or_create_guestasync def get_optional_current_user(    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),    db: AsyncSession = Depends(get_db)) -> Optional[User]:    """    Получение текущего пользователя (опционально).    Возвращает пользователя если токен предоставлен и валиден,    None в противном случае. Не вызывает исключений.    Args:        credentials: Опциональные учетные данные        db: Сессия базы данных    Returns:        Optional[User]: Пользователь или None    """    if not credentials:        return None    try:        return await get_current_user_from_token(credentials, db)    except HTTPException:        return None# НОВАЯ ФУНКЦИЯ: Получение пользователя для /users/me endpointasync def get_current_user(    current_user: User = Depends(get_current_user_from_token)) -> User:    """    Простое получение текущего пользователя для /users/me endpoint.    НОВАЯ ФУНКЦИЯ: Для устранения проблем с /users/me    Args:        current_user: Текущий аутентифицированный пользователь    Returns:        User: Текущий пользователь    """    return current_user