from typing import Optionalfrom fastapi import Depends, HTTPException, status, Cookie, Headerfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom sqlalchemy.ext.asyncio import AsyncSessionfrom jose import JWTError, jwtfrom app.core.db import get_dbfrom app.core.redis import get_redis, RedisClientfrom app.core.config import settingsfrom app.crud.user import user_crudfrom app.models.models import Userimport logginglogger = logging.getLogger(__name__)security = HTTPBearer(auto_error=False)async def get_current_user(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> Optional[User]:    """Получение текущего пользователя (зарегистрированного или гостевого)"""    # Попытка аутентификации по токену    if credentials:        try:            payload = jwt.decode(                credentials.credentials,                settings.secret_key,                algorithms=[settings.algorithm]            )            user_id: int = payload.get("sub")            if user_id:                user = await user_crud.get(db, id=user_id)                if user and user.is_active:                    return user        except JWTError:            pass    # Попытка получения гостевого пользователя    if session_id:        user = await user_crud.get_by_session_id(db, session_id=session_id)        if user:            return user    return Noneasync def get_current_active_user(        current_user: User = Depends(get_current_user)) -> User:    """Получение активного пользователя (обязательно)"""    if not current_user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Not authenticated"        )    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST,            detail="Inactive user"        )    return current_userasync def get_current_registered_user(        current_user: User = Depends(get_current_active_user)) -> User:    """Получение зарегистрированного пользователя"""    if current_user.is_guest:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Registration required"        )    return current_userasync def get_rate_limiter(        request_id: str = Header(None, alias="X-Request-ID"),        redis: RedisClient = Depends(get_redis)) -> bool:    """Rate limiting dependency"""    if not request_id:        return True    return await redis.rate_limit_check(        identifier=request_id,        limit=settings.rate_limit_requests,        window_seconds=settings.rate_limit_window    )