from typing import Optionalfrom fastapi import Depends, HTTPException, status, Cookie, Headerfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentialsfrom sqlalchemy.ext.asyncio import AsyncSessionfrom jose import JWTError, jwtfrom app.core.db import get_dbfrom app.core.redis import get_redis, RedisClientfrom app.core.config import settingsfrom app.crud.user import user_crudfrom app.models.models import Userimport loggingimport uuidlogger = logging.getLogger(__name__)security = HTTPBearer(auto_error=False)async def get_current_user(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> Optional[User]:    """Получение текущего пользователя (зарегистрированного или гостевого)"""    # Попытка аутентификации по токену    if credentials:        try:            payload = jwt.decode(                credentials.credentials,                settings.secret_key,                algorithms=[settings.algorithm]            )            user_id: int = payload.get("sub")            if user_id:                user = await user_crud.get(db, id=user_id)                if user and user.is_active:                    return user        except JWTError:            pass    # Попытка получения гостевого пользователя    if session_id:        user = await user_crud.get_by_session_id(db, session_id=session_id)        if user:            return user    return Noneasync def get_current_user_or_create_guest(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> User:    """Получение пользователя или создание гостевого если не найден"""    # Сначала пытаемся получить существующего пользователя    user = await get_current_user(db, credentials, session_id)    if user:        return user    # Если пользователь не найден, создаем гостевого    new_session_id = session_id or str(uuid.uuid4())    guest_user = await user_crud.create_guest_user(db, session_id=new_session_id)    return guest_userasync def get_current_user_from_token(        credentials: HTTPAuthorizationCredentials = Depends(security),        db: AsyncSession = Depends(get_db)) -> User:    """Получение пользователя строго из JWT токена (для защищенных роутов)"""    if not credentials:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Not authenticated",            headers={"WWW-Authenticate": "Bearer"},        )    try:        payload = jwt.decode(            credentials.credentials,            settings.secret_key,            algorithms=[settings.algorithm]        )        user_id: int = payload.get("sub")        if user_id is None:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="Could not validate credentials",                headers={"WWW-Authenticate": "Bearer"},            )        user = await user_crud.get(db, id=user_id)        if user is None:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail="User not found",                headers={"WWW-Authenticate": "Bearer"},            )        return user    except JWTError:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Could not validate credentials",            headers={"WWW-Authenticate": "Bearer"},        )async def get_current_active_user(        current_user: User = Depends(get_current_user)) -> User:    """Получение активного пользователя (обязательно)"""    if not current_user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail="Not authenticated"        )    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST,            detail="Inactive user"        )    return current_userasync def get_current_registered_user(        current_user: User = Depends(get_current_active_user)) -> User:    """Получение зарегистрированного пользователя"""    if current_user.is_guest:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Registration required"        )    return current_userasync def get_current_registered_user_from_token(        current_user: User = Depends(get_current_user_from_token)) -> User:    """Получение зарегистрированного пользователя строго из токена"""    if not current_user.is_active:        raise HTTPException(            status_code=status.HTTP_400_BAD_REQUEST,            detail="Inactive user"        )    if current_user.is_guest:        raise HTTPException(            status_code=status.HTTP_403_FORBIDDEN,            detail="Registration required"        )    return current_userasync def get_optional_user(        db: AsyncSession = Depends(get_db),        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),        session_id: Optional[str] = Cookie(None)) -> Optional[User]:    """Получение пользователя (опционально, без создания гостевого)"""    return await get_current_user(db, credentials, session_id)async def get_rate_limiter(        request_id: str = Header(None, alias="X-Request-ID"),        redis: RedisClient = Depends(get_redis)) -> bool:    """Rate limiting dependency"""    if not request_id:        return True    return await redis.rate_limit_check(        identifier=request_id,        limit=settings.rate_limit_requests,        window_seconds=settings.rate_limit_window    )