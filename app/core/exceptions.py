import loggingfrom fastapi import Request, statusfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import JSONResponsefrom sqlalchemy.exc import IntegrityError, SQLAlchemyErrorfrom starlette.exceptions import HTTPException as StarletteHTTPExceptionlogger = logging.getLogger(__name__)class BusinessLogicError(Exception):    """Базовое исключение для бизнес-логики"""    def __init__(self, message: str, code: str = "BUSINESS_ERROR"):        self.message = message        self.code = code        super().__init__(self.message)class InsufficientFundsError(BusinessLogicError):    """Недостаточно средств"""    def __init__(self, message: str = "Insufficient funds"):        super().__init__(message, "INSUFFICIENT_FUNDS")class ProductNotAvailableError(BusinessLogicError):    """Товар недоступен"""    def __init__(self, message: str = "Product not available"):        super().__init__(message, "PRODUCT_NOT_AVAILABLE")async def http_exception_handler(request: Request, exc: StarletteHTTPException):    """Обработчик HTTP исключений"""    logger.warning(f"HTTP {exc.status_code}: {exc.detail} - {request.url}")    return JSONResponse(        status_code=exc.status_code,        content={            "error": True,            "message": exc.detail,            "status_code": exc.status_code,            "path": str(request.url.path)        }    )async def validation_exception_handler(request: Request, exc: RequestValidationError):    """Обработчик ошибок валидации"""    logger.warning(f"Validation error: {exc.errors()} - {request.url}")    return JSONResponse(        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,        content={            "error": True,            "message": "Validation error",            "details": exc.errors(),            "status_code": 422,            "path": str(request.url.path)        }    )async def business_logic_exception_handler(request: Request, exc: BusinessLogicError):    """Обработчик бизнес-логических исключений"""    logger.warning(f"Business logic error: {exc.message} - {request.url}")    status_code_map = {        "INSUFFICIENT_FUNDS": status.HTTP_402_PAYMENT_REQUIRED,        "PRODUCT_NOT_AVAILABLE": status.HTTP_409_CONFLICT,        "BUSINESS_ERROR": status.HTTP_400_BAD_REQUEST    }    status_code = status_code_map.get(exc.code, status.HTTP_400_BAD_REQUEST)    return JSONResponse(        status_code=status_code,        content={            "error": True,            "message": exc.message,            "code": exc.code,            "status_code": status_code,            "path": str(request.url.path)        }    )async def database_exception_handler(request: Request, exc: SQLAlchemyError):    """Обработчик ошибок базы данных"""    logger.error(f"Database error: {str(exc)} - {request.url}")    if isinstance(exc, IntegrityError):        return JSONResponse(            status_code=status.HTTP_409_CONFLICT,            content={                "error": True,                "message": "Data integrity constraint violation",                "status_code": 409,                "path": str(request.url.path)            }        )    return JSONResponse(        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,        content={            "error": True,            "message": "Database operation failed",            "status_code": 500,            "path": str(request.url.path)        }    )async def general_exception_handler(request: Request, exc: Exception):    """Общий обработчик исключений"""    logger.error(f"Unexpected error: {str(exc)} - {request.url}", exc_info=True)    return JSONResponse(        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,        content={            "error": True,            "message": "Internal server error",            "status_code": 500,            "path": str(request.url.path)        }    )