"""Система обработки исключений приложения.Содержит кастомные исключения для бизнес-логики и их обработчики.Обеспечивает единообразное форматирование ошибок API."""import loggingimport tracebackfrom typing import Dict, Any, Optionalfrom fastapi import Request, statusfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import JSONResponsefrom sqlalchemy.exc import IntegrityError, SQLAlchemyError, DatabaseErrorfrom starlette.exceptions import HTTPException as StarletteHTTPExceptionlogger = logging.getLogger(__name__)class BusinessLogicError(Exception):    """    Базовое исключение для бизнес-логики приложения.    Используется для обработки ошибок, связанных с нарушением    бизнес-правил и ограничений приложения.    """    def __init__(            self,            message: str,            code: str = "BUSINESS_ERROR",            details: Optional[Dict[str, Any]] = None    ):        """        Инициализация исключения бизнес-логики.        Args:            message: Человекочитаемое описание ошибки            code: Код ошибки для программной обработки            details: Дополнительные детали ошибки        """        self.message = message        self.code = code        self.details = details or {}        super().__init__(self.message)    def __str__(self) -> str:        return f"{self.code}: {self.message}"    def to_dict(self) -> Dict[str, Any]:        """Преобразование исключения в словарь."""        return {            "error": True,            "message": self.message,            "code": self.code,            "details": self.details        }class ValidationError(BusinessLogicError):    """Ошибка валидации данных."""    def __init__(self, message: str = "Validation failed", field: str = None, details: Dict = None):        super().__init__(message, "VALIDATION_ERROR", details)        self.field = fieldclass AuthenticationError(BusinessLogicError):    """Ошибка аутентификации."""    def __init__(self, message: str = "Authentication failed"):        super().__init__(message, "AUTHENTICATION_ERROR")class AuthorizationError(BusinessLogicError):    """Ошибка авторизации."""    def __init__(self, message: str = "Access forbidden"):        super().__init__(message, "AUTHORIZATION_ERROR")class InsufficientFundsError(BusinessLogicError):    """Ошибка недостаточности средств."""    def __init__(            self,            message: str = "Insufficient funds",            required_amount: str = None,            available_amount: str = None    ):        details = {}        if required_amount:            details["required_amount"] = required_amount        if available_amount:            details["available_amount"] = available_amount        super().__init__(message, "INSUFFICIENT_FUNDS", details)class ProductNotAvailableError(BusinessLogicError):    """Ошибка недоступности товара."""    def __init__(            self,            message: str = "Product not available",            product_id: int = None,            requested_quantity: int = None,            available_quantity: int = None    ):        details = {}        if product_id:            details["product_id"] = product_id        if requested_quantity:            details["requested_quantity"] = requested_quantity        if available_quantity:            details["available_quantity"] = available_quantity        super().__init__(message, "PRODUCT_NOT_AVAILABLE", details)class OrderProcessingError(BusinessLogicError):    """Ошибка обработки заказа."""    def __init__(self, message: str = "Order processing failed", order_id: str = None):        details = {"order_id": order_id} if order_id else {}        super().__init__(message, "ORDER_PROCESSING_ERROR", details)class PaymentError(BusinessLogicError):    """Ошибка платежа."""    def __init__(            self,            message: str = "Payment failed",            transaction_id: str = None,            provider_error: str = None    ):        details = {}        if transaction_id:            details["transaction_id"] = transaction_id        if provider_error:            details["provider_error"] = provider_error        super().__init__(message, "PAYMENT_ERROR", details)class ExternalServiceError(BusinessLogicError):    """Ошибка внешнего сервиса."""    def __init__(            self,            message: str = "External service error",            service_name: str = None,            status_code: int = None    ):        details = {}        if service_name:            details["service_name"] = service_name        if status_code:            details["status_code"] = status_code        super().__init__(message, "EXTERNAL_SERVICE_ERROR", details)class RateLimitError(BusinessLogicError):    """Ошибка превышения лимита запросов."""    def __init__(            self,            message: str = "Rate limit exceeded",            limit: int = None,            reset_time: int = None    ):        details = {}        if limit:            details["limit"] = limit        if reset_time:            details["reset_time"] = reset_time        super().__init__(message, "RATE_LIMIT_ERROR", details)def create_error_response(        status_code: int,        message: str,        error_code: str = None,        details: Dict[str, Any] = None,        path: str = None) -> JSONResponse:    """    Создание стандартизированного ответа об ошибке.    Args:        status_code: HTTP статус код        message: Сообщение об ошибке        error_code: Код ошибки        details: Дополнительные детали        path: Путь запроса    Returns:        JSONResponse: Форматированный ответ об ошибке    """    from datetime import datetime    content = {        "error": True,        "message": message,        "status_code": status_code,        "timestamp": datetime.now().isoformat(),    }    if error_code:        content["code"] = error_code    if details:        content["details"] = details    if path:        content["path"] = path    return JSONResponse(status_code=status_code, content=content)async def http_exception_handler(request: Request, exc: StarletteHTTPException) -> JSONResponse:    """    Обработчик HTTP исключений.    Обрабатывает стандартные HTTP ошибки FastAPI и Starlette.    """    logger.warning(        f"HTTP {exc.status_code}: {exc.detail} - "        f"{request.method} {request.url.path} - "        f"Client: {request.client.host if request.client else 'unknown'}"    )    return create_error_response(        status_code=exc.status_code,        message=exc.detail,        error_code="HTTP_ERROR",        path=str(request.url.path)    )async def validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:    """    Обработчик ошибок валидации Pydantic.    Форматирует ошибки валидации в удобочитаемый формат.    """    logger.warning(        f"Validation error: {len(exc.errors())} errors - "        f"{request.method} {request.url.path} - "        f"Client: {request.client.host if request.client else 'unknown'}"    )    # Форматируем ошибки валидации    formatted_errors = []    for error in exc.errors():        field = " -> ".join(str(loc) for loc in error["loc"])        formatted_errors.append({            "field": field,            "message": error["msg"],            "type": error["type"],            "input": error.get("input")        })    return create_error_response(        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,        message="Validation failed",        error_code="VALIDATION_ERROR",        details={"errors": formatted_errors},        path=str(request.url.path)    )async def business_logic_exception_handler(request: Request, exc: BusinessLogicError) -> JSONResponse:    """    Обработчик бизнес-логических исключений.    Преобразует бизнес-ошибки в соответствующие HTTP статусы.    """    logger.warning(        f"Business logic error: {exc.code} - {exc.message} - "        f"{request.method} {request.url.path} - "        f"Client: {request.client.host if request.client else 'unknown'}"    )    # Маппинг кодов ошибок на HTTP статусы    status_code_map = {        "VALIDATION_ERROR": status.HTTP_422_UNPROCESSABLE_ENTITY,        "AUTHENTICATION_ERROR": status.HTTP_401_UNAUTHORIZED,        "AUTHORIZATION_ERROR": status.HTTP_403_FORBIDDEN,        "INSUFFICIENT_FUNDS": status.HTTP_402_PAYMENT_REQUIRED,        "PRODUCT_NOT_AVAILABLE": status.HTTP_409_CONFLICT,        "ORDER_PROCESSING_ERROR": status.HTTP_409_CONFLICT,        "PAYMENT_ERROR": status.HTTP_402_PAYMENT_REQUIRED,        "EXTERNAL_SERVICE_ERROR": status.HTTP_503_SERVICE_UNAVAILABLE,        "RATE_LIMIT_ERROR": status.HTTP_429_TOO_MANY_REQUESTS,        "BUSINESS_ERROR": status.HTTP_400_BAD_REQUEST    }    status_code = status_code_map.get(exc.code, status.HTTP_400_BAD_REQUEST)    return create_error_response(        status_code=status_code,        message=exc.message,        error_code=exc.code,        details=exc.details,        path=str(request.url.path)    )async def database_exception_handler(request: Request, exc: SQLAlchemyError) -> JSONResponse:    """    Обработчик ошибок базы данных.    Обрабатывает различные типы ошибок SQLAlchemy.    """    logger.error(        f"Database error: {type(exc).__name__} - {str(exc)} - "        f"{request.method} {request.url.path} - "        f"Client: {request.client.host if request.client else 'unknown'}",        exc_info=True    )    if isinstance(exc, IntegrityError):        # Ошибки целостности данных        return create_error_response(            status_code=status.HTTP_409_CONFLICT,            message="Data integrity constraint violation",            error_code="INTEGRITY_ERROR",            details={"database_error": str(exc.orig) if hasattr(exc, 'orig') else str(exc)},            path=str(request.url.path)        )    elif isinstance(exc, DatabaseError):        # Ошибки подключения к базе данных        return create_error_response(            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,            message="Database connection error",            error_code="DATABASE_CONNECTION_ERROR",            path=str(request.url.path)        )    # Общие ошибки базы данных    return create_error_response(        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,        message="Database operation failed",        error_code="DATABASE_ERROR",        path=str(request.url.path)    )async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:    """    Общий обработчик неожиданных исключений.    Логирует полную информацию об ошибке и возвращает общий ответ.    """    # Генерируем уникальный ID ошибки для отслеживания    import uuid    error_id = str(uuid.uuid4())[:8]    logger.error(        f"Unexpected error [{error_id}]: {type(exc).__name__} - {str(exc)} - "        f"{request.method} {request.url.path} - "        f"Client: {request.client.host if request.client else 'unknown'}",        exc_info=True    )    # В production не показываем детали ошибки    from app.core.config import settings    if settings.is_production():        message = "Internal server error"        details = {"error_id": error_id}    else:        message = f"Internal server error: {str(exc)}"        details = {            "error_id": error_id,            "exception_type": type(exc).__name__,            "traceback": traceback.format_exc().split('\n')        }    return create_error_response(        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,        message=message,        error_code="INTERNAL_ERROR",        details=details,        path=str(request.url.path)    )def setup_exception_handlers(app):    """    Настройка обработчиков исключений для приложения FastAPI.    Args:        app: Экземпляр FastAPI приложения    """    # Порядок регистрации важен - от конкретного к общему    app.add_exception_handler(BusinessLogicError, business_logic_exception_handler)    app.add_exception_handler(SQLAlchemyError, database_exception_handler)    app.add_exception_handler(RequestValidationError, validation_exception_handler)    app.add_exception_handler(StarletteHTTPException, http_exception_handler)    app.add_exception_handler(Exception, general_exception_handler)    logger.info("Exception handlers configured")class ServiceUnavailableError(Exception):    """Исключение для недоступности сервиса."""    def __init__(self, message: str = "Service temporarily unavailable"):        self.message = message        super().__init__(self.message)