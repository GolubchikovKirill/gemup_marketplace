-- Инициализация базы данных PostgreSQL для Gemup Marketplace-- Этот файл выполняется при первом развертывании для настройки БД-- Создание расширений PostgreSQLCREATE EXTENSION IF NOT EXISTS "uuid-ossp" SCHEMA public;CREATE EXTENSION IF NOT EXISTS "pg_trgm" SCHEMA public;CREATE EXTENSION IF NOT EXISTS "btree_gin" SCHEMA public;CREATE EXTENSION IF NOT EXISTS "btree_gist" SCHEMA public;-- Настройка часового поясаSET timezone = 'UTC';-- Создание дополнительных типов данныхDO $$ BEGIN    -- Проверяем существование enum типов    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'proxy_type_enum') THEN        CREATE TYPE proxy_type_enum AS ENUM ('http', 'https', 'socks4', 'socks5');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'proxy_category_enum') THEN        CREATE TYPE proxy_category_enum AS ENUM ('residential', 'datacenter', 'isp', 'nodepay', 'grass');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'session_type_enum') THEN        CREATE TYPE session_type_enum AS ENUM ('sticky', 'rotating');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'provider_type_enum') THEN        CREATE TYPE provider_type_enum AS ENUM ('711', 'proxy_seller', 'lightning', 'goproxy', 'smartproxy', 'oxylabs');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'order_status_enum') THEN        CREATE TYPE order_status_enum AS ENUM ('pending', 'paid', 'processing', 'completed', 'cancelled', 'failed', 'refunded');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN        CREATE TYPE transaction_type_enum AS ENUM ('deposit', 'purchase', 'refund', 'withdrawal');    END IF;    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN        CREATE TYPE transaction_status_enum AS ENUM ('pending', 'completed', 'failed', 'cancelled');    END IF;END $$;-- Создание функций для автоматического обновления updated_atCREATE OR REPLACE FUNCTION update_updated_at_column()RETURNS TRIGGER AS $$BEGIN    NEW.updated_at = CURRENT_TIMESTAMP;    RETURN NEW;END;$$ language 'plpgsql';-- Функция для генерации номеров заказовCREATE OR REPLACE FUNCTION generate_order_number()RETURNS TEXT AS $$DECLARE    order_date TEXT;    random_suffix TEXT;BEGIN    order_date := TO_CHAR(CURRENT_DATE, 'YYYYMMDD');    random_suffix := UPPER(SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 5));    RETURN 'ORD-' || order_date || '-' || random_suffix;END;$$ LANGUAGE plpgsql;-- Функция для генерации ID транзакцийCREATE OR REPLACE FUNCTION generate_transaction_id()RETURNS TEXT AS $$DECLARE    txn_date TEXT;    random_suffix TEXT;BEGIN    txn_date := TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD');    random_suffix := UPPER(SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8));    RETURN 'TXN-' || txn_date || '-' || random_suffix;END;$$ LANGUAGE plpgsql;-- Функция для логирования изменений балансаCREATE OR REPLACE FUNCTION log_balance_change()RETURNS TRIGGER AS $$BEGIN    -- Логируем только если баланс действительно изменился    IF OLD.balance IS DISTINCT FROM NEW.balance THEN        INSERT INTO balance_history (            user_id,            old_balance,            new_balance,            change_amount,            operation_type,            created_at        ) VALUES (            NEW.id,            OLD.balance,            NEW.balance,            NEW.balance - OLD.balance,            'system_update',            CURRENT_TIMESTAMP        );    END IF;    RETURN NEW;END;$$ LANGUAGE plpgsql;-- Создание таблицы для логирования изменений балансаCREATE TABLE IF NOT EXISTS balance_history (    id SERIAL PRIMARY KEY,    user_id INTEGER NOT NULL,    old_balance DECIMAL(15,8) NOT NULL,    new_balance DECIMAL(15,8) NOT NULL,    change_amount DECIMAL(15,8) NOT NULL,    operation_type VARCHAR(50) NOT NULL,    reference_id VARCHAR(255),    notes TEXT,    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP);-- Создание индексов для balance_historyCREATE INDEX IF NOT EXISTS idx_balance_history_user_id ON balance_history(user_id);CREATE INDEX IF NOT EXISTS idx_balance_history_created_at ON balance_history(created_at);CREATE INDEX IF NOT EXISTS idx_balance_history_operation_type ON balance_history(operation_type);-- Создание таблицы для audit логовCREATE TABLE IF NOT EXISTS audit_log (    id SERIAL PRIMARY KEY,    table_name VARCHAR(50) NOT NULL,    operation VARCHAR(10) NOT NULL, -- INSERT, UPDATE, DELETE    old_data JSONB,    new_data JSONB,    user_id INTEGER,    ip_address INET,    user_agent TEXT,    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP);-- Индексы для audit_logCREATE INDEX IF NOT EXISTS idx_audit_log_table_name ON audit_log(table_name);CREATE INDEX IF NOT EXISTS idx_audit_log_operation ON audit_log(operation);CREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at);-- Функция для audit логированияCREATE OR REPLACE FUNCTION audit_trigger()RETURNS TRIGGER AS $$BEGIN    IF TG_OP = 'DELETE' THEN        INSERT INTO audit_log (table_name, operation, old_data, created_at)        VALUES (TG_TABLE_NAME, TG_OP, to_jsonb(OLD), CURRENT_TIMESTAMP);        RETURN OLD;    ELSIF TG_OP = 'UPDATE' THEN        INSERT INTO audit_log (table_name, operation, old_data, new_data, created_at)        VALUES (TG_TABLE_NAME, TG_OP, to_jsonb(OLD), to_jsonb(NEW), CURRENT_TIMESTAMP);        RETURN NEW;    ELSIF TG_OP = 'INSERT' THEN        INSERT INTO audit_log (table_name, operation, new_data, created_at)        VALUES (TG_TABLE_NAME, TG_OP, to_jsonb(NEW), CURRENT_TIMESTAMP);        RETURN NEW;    END IF;    RETURN NULL;END;$$ LANGUAGE plpgsql;-- Создание полнотекстового поиска для продуктовCREATE OR REPLACE FUNCTION create_product_search_index()RETURNS VOID AS $$BEGIN    -- Добавляем колонку для полнотекстового поиска если её нет    IF NOT EXISTS (        SELECT 1 FROM information_schema.columns        WHERE table_name = 'proxy_products' AND column_name = 'search_vector'    ) THEN        ALTER TABLE proxy_products ADD COLUMN search_vector tsvector;    END IF;    -- Создаем индекс для поиска    CREATE INDEX IF NOT EXISTS idx_proxy_products_search    ON proxy_products USING gin(search_vector);    -- Функция для обновления search_vector    CREATE OR REPLACE FUNCTION update_product_search_vector()    RETURNS TRIGGER AS $trigger$    BEGIN        NEW.search_vector :=            setweight(to_tsvector('english', COALESCE(NEW.name, '')), 'A') ||            setweight(to_tsvector('english', COALESCE(NEW.description, '')), 'B') ||            setweight(to_tsvector('english', COALESCE(NEW.country_name, '')), 'C') ||            setweight(to_tsvector('english', COALESCE(NEW.city, '')), 'D');        RETURN NEW;    END;    $trigger$ LANGUAGE plpgsql;END;$$ LANGUAGE plpgsql;-- Создание индексов для оптимизации производительностиCREATE INDEX IF NOT EXISTS idx_users_email_active ON users(email, is_active) WHERE email IS NOT NULL;CREATE INDEX IF NOT EXISTS idx_users_guest_session ON users(guest_session_id, guest_expires_at) WHERE is_guest = true;CREATE INDEX IF NOT EXISTS idx_users_balance ON users(balance) WHERE balance > 0;CREATE INDEX IF NOT EXISTS idx_proxy_products_category_active ON proxy_products(proxy_category, is_active);CREATE INDEX IF NOT EXISTS idx_proxy_products_provider_country ON proxy_products(provider, country_code);CREATE INDEX IF NOT EXISTS idx_proxy_products_price_range ON proxy_products(price_per_proxy, proxy_category);CREATE INDEX IF NOT EXISTS idx_proxy_products_featured ON proxy_products(is_featured, is_active) WHERE is_featured = true;CREATE INDEX IF NOT EXISTS idx_proxy_products_stock ON proxy_products(stock_available, is_active) WHERE stock_available > 0;CREATE INDEX IF NOT EXISTS idx_orders_user_status ON orders(user_id, status);CREATE INDEX IF NOT EXISTS idx_orders_status_created ON orders(status, created_at);CREATE INDEX IF NOT EXISTS idx_orders_payment_id ON orders(payment_id) WHERE payment_id IS NOT NULL;CREATE INDEX IF NOT EXISTS idx_transactions_user_type ON transactions(user_id, transaction_type);CREATE INDEX IF NOT EXISTS idx_transactions_status_created ON transactions(status, created_at);CREATE INDEX IF NOT EXISTS idx_transactions_external_id ON transactions(external_transaction_id) WHERE external_transaction_id IS NOT NULL;CREATE INDEX IF NOT EXISTS idx_proxy_purchases_user_active ON proxy_purchases(user_id, is_active);CREATE INDEX IF NOT EXISTS idx_proxy_purchases_expires ON proxy_purchases(expires_at, is_active);CREATE INDEX IF NOT EXISTS idx_proxy_purchases_provider_order ON proxy_purchases(provider_order_id) WHERE provider_order_id IS NOT NULL;CREATE INDEX IF NOT EXISTS idx_shopping_carts_user ON shopping_carts(user_id) WHERE user_id IS NOT NULL;CREATE INDEX IF NOT EXISTS idx_shopping_carts_session ON shopping_carts(session_id, expires_at) WHERE session_id IS NOT NULL;-- Создание составных индексов для частых запросовCREATE INDEX IF NOT EXISTS idx_proxy_products_filter ON proxy_products(proxy_category, provider, country_code, is_active);CREATE INDEX IF NOT EXISTS idx_orders_user_date ON orders(user_id, created_at DESC);CREATE INDEX IF NOT EXISTS idx_transactions_user_date ON transactions(user_id, created_at DESC);-- Настройка статистики для оптимизатораALTER TABLE proxy_products ALTER COLUMN proxy_category SET STATISTICS 1000;ALTER TABLE proxy_products ALTER COLUMN provider SET STATISTICS 1000;ALTER TABLE proxy_products ALTER COLUMN country_code SET STATISTICS 1000;ALTER TABLE orders ALTER COLUMN status SET STATISTICS 1000;ALTER TABLE transactions ALTER COLUMN status SET STATISTICS 1000;-- Создание ролей для приложенияDO $$ BEGIN    -- Роль для приложения (чтение/запись)    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'gemup_app') THEN        CREATE ROLE gemup_app LOGIN PASSWORD 'change_me_in_production';    END IF;    -- Роль только для чтения (для аналитики)    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'gemup_readonly') THEN        CREATE ROLE gemup_readonly LOGIN PASSWORD 'readonly_password';    END IF;    -- Роль для бэкапов    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'gemup_backup') THEN        CREATE ROLE gemup_backup LOGIN PASSWORD 'backup_password';    END IF;END $$;-- Настройки производительности PostgreSQL-- (выполняются только если текущий пользователь имеет права суперпользователя)DO $$ BEGIN    IF EXISTS (SELECT 1 FROM pg_user WHERE usename = current_user AND usesuper = true) THEN        -- Оптимизация параметров для маркетплейса        PERFORM set_config('work_mem', '64MB', false);        PERFORM set_config('maintenance_work_mem', '256MB', false);        PERFORM set_config('effective_cache_size', '2GB', false);        PERFORM set_config('random_page_cost', '1.5', false);        PERFORM set_config('checkpoint_completion_target', '0.9', false);        PERFORM set_config('wal_buffers', '16MB', false);        PERFORM set_config('default_statistics_target', '500', false);    END IF;EXCEPTION    WHEN insufficient_privilege THEN        RAISE NOTICE 'Insufficient privileges to set PostgreSQL parameters. This is normal in managed database environments.';END $$;-- Создание представлений для аналитикиCREATE OR REPLACE VIEW user_statistics ASSELECT    u.id,    u.email,    u.created_at as registration_date,    u.balance,    COUNT(DISTINCT o.id) as total_orders,    COALESCE(SUM(o.total_amount), 0) as total_spent,    COUNT(DISTINCT pp.id) as active_proxies,    MAX(o.created_at) as last_order_dateFROM users uLEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed'LEFT JOIN proxy_purchases pp ON u.id = pp.user_id AND pp.is_active = trueWHERE u.is_guest = falseGROUP BY u.id, u.email, u.created_at, u.balance;CREATE OR REPLACE VIEW product_analytics ASSELECT    pp.id,    pp.name,    pp.proxy_category,    pp.provider,    pp.country_name,    pp.price_per_proxy,    pp.stock_available,    COUNT(DISTINCT oi.id) as total_sales,    COALESCE(SUM(oi.quantity), 0) as total_quantity_sold,    COALESCE(SUM(oi.total_price), 0) as total_revenue,    AVG(oi.unit_price) as avg_selling_priceFROM proxy_products ppLEFT JOIN order_items oi ON pp.id = oi.proxy_product_idLEFT JOIN orders o ON oi.order_id = o.id AND o.status = 'completed'GROUP BY pp.id, pp.name, pp.proxy_category, pp.provider, pp.country_name, pp.price_per_proxy, pp.stock_available;-- Создание материализованного представления для дашбордаCREATE MATERIALIZED VIEW IF NOT EXISTS dashboard_stats ASSELECT    (SELECT COUNT(*) FROM users WHERE is_guest = false) as total_users,    (SELECT COUNT(*) FROM users WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND is_guest = false) as new_users_30d,    (SELECT COUNT(*) FROM orders WHERE status = 'completed') as total_orders,    (SELECT COUNT(*) FROM orders WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND status = 'completed') as orders_30d,    (SELECT COALESCE(SUM(total_amount), 0) FROM orders WHERE status = 'completed') as total_revenue,    (SELECT COALESCE(SUM(total_amount), 0) FROM orders WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND status = 'completed') as revenue_30d,    (SELECT COUNT(*) FROM proxy_purchases WHERE is_active = true) as active_proxies,    (SELECT COUNT(DISTINCT provider) FROM proxy_products WHERE is_active = true) as active_providers,    CURRENT_TIMESTAMP as last_updated;-- Создание индекса для материализованного представленияCREATE UNIQUE INDEX IF NOT EXISTS idx_dashboard_stats_updated ON dashboard_stats(last_updated);-- Функция для обновления статистики дашбордаCREATE OR REPLACE FUNCTION refresh_dashboard_stats()RETURNS VOID AS $$BEGIN    REFRESH MATERIALIZED VIEW dashboard_stats;END;$$ LANGUAGE plpgsql;-- Планирование автоматического обновления статистики (если есть pg_cron)-- SELECT cron.schedule('refresh-dashboard-stats', '*/15 * * * *', 'SELECT refresh_dashboard_stats();');-- Настройка логирования изменений (только для критических таблиц)DO $$ BEGIN    -- Включаем audit для пользователей    DROP TRIGGER IF EXISTS audit_users_trigger ON users;    CREATE TRIGGER audit_users_trigger        AFTER INSERT OR UPDATE OR DELETE ON users        FOR EACH ROW EXECUTE FUNCTION audit_trigger();    -- Включаем audit для заказов    DROP TRIGGER IF EXISTS audit_orders_trigger ON orders;    CREATE TRIGGER audit_orders_trigger        AFTER INSERT OR UPDATE OR DELETE ON orders        FOR EACH ROW EXECUTE FUNCTION audit_trigger();    -- Включаем audit для транзакций    DROP TRIGGER IF EXISTS audit_transactions_trigger ON transactions;    CREATE TRIGGER audit_transactions_trigger        AFTER INSERT OR UPDATE OR DELETE ON transactions        FOR EACH ROW EXECUTE FUNCTION audit_trigger();END $$;-- Финальные настройкиANALYZE;-- Сообщение о завершенииDO $$ BEGIN    RAISE NOTICE 'Gemup Marketplace database initialization completed successfully!';    RAISE NOTICE 'Created extensions: uuid-ossp, pg_trgm, btree_gin, btree_gist';    RAISE NOTICE 'Created custom types for enums';    RAISE NOTICE 'Created utility functions and triggers';    RAISE NOTICE 'Created performance indexes';    RAISE NOTICE 'Created analytics views';    RAISE NOTICE 'Configured audit logging';    RAISE NOTICE 'Database is ready for the application!';END $$;