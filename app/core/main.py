"""–ì–ª–∞–≤–Ω—ã–π –º–æ–¥—É–ª—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è FastAPI.–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è FastAPI- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ middleware –∏ —Ä–æ—É—Ç–æ–≤- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ lifecycle events- Health checks –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"""import loggingfrom contextlib import asynccontextmanagerfrom datetime import datetimefrom typing import Dict, Anyfrom fastapi import FastAPI, Requestfrom fastapi.responses import JSONResponsefrom starlette.exceptions import HTTPException as StarletteHTTPExceptionfrom app.core.config import settingsfrom app.core.db import close_db, check_db_healthfrom app.core.logging_config import setup_loggingfrom app.core.middleware import setup_middleware, setup_error_handlersfrom app.core.migrations import init_alembicfrom app.core.redis import redis_client, get_redis_healthfrom app.routes import (    auth,    users,    products,    cart,    orders,    payments,    proxies)# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—èsetup_logging()logger = logging.getLogger(__name__)# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –º–µ—Ç—Ä–∏–∫app_start_time = datetime.now()request_count = 0error_count = 0startup_tasks: list = []startup_errors: list = []@asynccontextmanagerasync def lifespan(application: FastAPI):    """    –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.    –í—ã–ø–æ–ª–Ω—è–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏ –æ—á–∏—Å—Ç–∫–µ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏.    Args:        application: –≠–∫–∑–µ–º–ø–ª—è—Ä FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è    """    global startup_tasks, startup_errors  # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ    # === STARTUP ===    logger.info("üöÄ Starting Gemup Marketplace API...")    logger.info(f"üìä Environment: {settings.environment}")    logger.info(f"üìä Debug mode: {settings.debug}")    logger.info(f"üìä Version: {settings.app_version}")    startup_tasks = []    startup_errors = []    try:        # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î        logger.info("üîÑ Checking database connection...")        db_healthy = await check_db_health()        if db_healthy:            logger.info("‚úÖ Database connection established")            startup_tasks.append("Database")        else:            logger.error("‚ùå Database connection failed")            startup_errors.append("Database connection failed")    except Exception as db_error:        logger.error(f"‚ùå Database initialization error: {db_error}")        startup_errors.append(f"Database: {str(db_error)}")    try:        # 2. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis        logger.info("üîÑ Connecting to Redis...")        await redis_client.connect()        redis_healthy = await get_redis_health()        if redis_healthy:            logger.info("‚úÖ Redis connection established")            startup_tasks.append("Redis")        else:            logger.warning("‚ö†Ô∏è Redis connection failed, continuing without cache")            startup_errors.append("Redis connection failed")    except Exception as redis_error:        logger.error(f"‚ùå Redis connection error: {redis_error}")        startup_errors.append(f"Redis: {str(redis_error)}")    try:        # 3. –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π (–Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–µ)        if settings.environment != "test":            logger.info("üîÑ Running database migrations...")            await init_alembic()            logger.info("‚úÖ Database migrations completed")            startup_tasks.append("Migrations")    except Exception as migration_error:        logger.warning(f"‚ö†Ô∏è Migration error (non-critical): {migration_error}")        startup_errors.append(f"Migrations: {str(migration_error)}")    # 4. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è    try:        # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–π        if hasattr(redis_client, 'redis') and redis_client.redis:            if hasattr(redis_client, 'cleanup_expired_sessions'):                cleaned = await redis_client.cleanup_expired_sessions()                logger.info(f"üßπ Cleaned {cleaned} expired sessions")        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫        if hasattr(settings, 'validate_required_settings'):            missing_settings = settings.validate_required_settings()            if missing_settings:                logger.warning(f"‚ö†Ô∏è Missing settings: {', '.join(missing_settings)}")                startup_errors.extend(missing_settings)    except Exception as init_error:        logger.error(f"‚ùå Additional initialization error: {init_error}")        startup_errors.append(f"Additional init: {str(init_error)}")    # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–ø—É—Å–∫–∞    logger.info(f"‚úÖ Startup completed. Tasks: {', '.join(startup_tasks)}")    if startup_errors:        logger.warning(f"‚ö†Ô∏è Startup warnings: {', '.join(startup_errors)}")    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ state    try:        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º state –µ—Å–ª–∏ –Ω—É–∂–Ω–æ        if not hasattr(application, 'state'):            from starlette.datastructures import State            application.state = State()        application.state.startup_time = app_start_time        application.state.startup_tasks = startup_tasks.copy()        application.state.startup_errors = startup_errors.copy()    except Exception as state_error:        logger.warning(f"Could not save to app.state: {state_error}")    logger.info("üéâ Gemup Marketplace API is ready!")    yield    # === SHUTDOWN ===    logger.info("üõë Shutting down Gemup Marketplace API...")    shutdown_tasks = []    shutdown_errors = []    try:        # 1. –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ë–î        logger.info("üîÑ Closing database connections...")        await close_db()        logger.info("‚úÖ Database connections closed")        shutdown_tasks.append("Database")    except Exception as db_shutdown_error:        logger.error(f"‚ùå Database shutdown error: {db_shutdown_error}")        shutdown_errors.append(f"Database: {str(db_shutdown_error)}")    try:        # 2. –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç Redis        logger.info("üîÑ Disconnecting from Redis...")        await redis_client.disconnect()        logger.info("‚úÖ Redis disconnected")        shutdown_tasks.append("Redis")    except Exception as redis_shutdown_error:        logger.error(f"‚ùå Redis shutdown error: {redis_shutdown_error}")        shutdown_errors.append(f"Redis: {str(redis_shutdown_error)}")    # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è    logger.info(f"‚úÖ Shutdown completed. Tasks: {', '.join(shutdown_tasks)}")    if shutdown_errors:        logger.warning(f"‚ö†Ô∏è Shutdown warnings: {', '.join(shutdown_errors)}")    logger.info("üëã Gemup Marketplace API stopped")def create_application() -> FastAPI:    """    –°–æ–∑–¥–∞–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.    Returns:        FastAPI: –ù–∞—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ    """    # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π    application = FastAPI(        title=settings.app_name,        version=settings.app_version,        description="API –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞ –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä–æ–≤ –¥–ª—è Web3 –ø—Ä–æ–µ–∫—Ç–æ–≤",        # –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è        #docs_url=getattr(settings, 'effective_docs_url', '/docs'),        #redoc_url=getattr(settings, 'effective_redoc_url', '/redoc'),        #openapi_url="/openapi.json" if not settings.is_production() else None,        docs_url="/docs",        redoc_url="/redoc",        openapi_url="/openapi.json",        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏        debug=settings.debug,        lifespan=lifespan,        # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ        contact={            "name": "Gemup Support",            "email": "support@gemup.com",            "url": "https://gemup.com/support"        },        license_info={            "name": "Proprietary",            "url": "https://gemup.com/license"        },        # OpenAPI —Ç–µ–≥–∏        openapi_tags=[            {                "name": "Authentication",                "description": "–û–ø–µ—Ä–∞—Ü–∏–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"            },            {                "name": "Users",                "description": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏"            },            {                "name": "Products",                "description": "–ö–∞—Ç–∞–ª–æ–≥ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –ø—Ä–æ–∫—Å–∏"            },            {                "name": "Cart",                "description": "–ö–æ—Ä–∑–∏–Ω–∞ –ø–æ–∫—É–ø–æ–∫"            },            {                "name": "Orders",                "description": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞–º–∏"            },            {                "name": "Payments",                "description": "–ü–ª–∞—Ç–µ–∂–∏ –∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"            },            {                "name": "Proxies",                "description": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—É–ø–ª–µ–Ω–Ω—ã–º–∏ –ø—Ä–æ–∫—Å–∏"            }        ]    )    return application# –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—èapp = create_application()# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ middlewaresetup_middleware(app)# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –æ—à–∏–±–æ–∫setup_error_handlers(app)def get_app_state_data(key: str, default=None):    """    –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ app.state.    Args:        key: –ö–ª—é—á –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è        default: –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é    Returns:        –ó–Ω–∞—á–µ–Ω–∏–µ –∏–∑ state –∏–ª–∏ default    """    try:        if hasattr(app, 'state') and hasattr(app.state, key):            return getattr(app.state, key)        return default    except Exception:        return default@app.get("/", tags=["System"])async def root() -> Dict[str, Any]:    """    –ö–æ—Ä–Ω–µ–≤–æ–π endpoint –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ API.    Returns:        Dict: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏    """    global request_count    request_count += 1    uptime_seconds = int((datetime.now() - app_start_time).total_seconds())    return {        "message": "Gemup Marketplace API",        "app": settings.app_name,        "version": settings.app_version,        "status": "running",        "environment": settings.environment,        "uptime_seconds": uptime_seconds,        "docs_url": getattr(settings, 'effective_docs_url', '/docs'),        "api_prefix": settings.api_prefix    }@app.get("/health", tags=["System"])async def health_check() -> Dict[str, Any]:    """    –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã.    –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –≤—Å–µ—Ö –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤.    Returns:        Dict: –°—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã    """    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤    db_status = await check_db_health()    redis_status = await get_redis_health()    # –û–±—â–∏–π —Å—Ç–∞—Ç—É—Å    overall_status = "healthy" if (db_status and redis_status) else "degraded"    if not db_status:        overall_status = "unhealthy"    # –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã    uptime_seconds = int((datetime.now() - app_start_time).total_seconds())    # –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏    health_data = {        "status": overall_status,        "timestamp": datetime.now().isoformat(),        "uptime_seconds": uptime_seconds,        "environment": settings.environment,        "version": settings.app_version,        # –°—Ç–∞—Ç—É—Å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤        "components": {            "database": "healthy" if db_status else "unhealthy",            "redis": "healthy" if redis_status else "unhealthy",            "application": "healthy"        },        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞        "metrics": {            "total_requests": request_count,            "total_errors": error_count,            "enabled_providers": getattr(settings, 'get_enabled_proxy_providers', lambda: [])()        }    }    startup_data = {        "completed_tasks": get_app_state_data("startup_tasks", startup_tasks),        "errors": get_app_state_data("startup_errors", startup_errors),        "startup_time": get_app_state_data("startup_time", app_start_time).isoformat()    }    health_data["startup"] = startup_data    return health_data@app.get("/metrics", tags=["System"])async def metrics() -> Dict[str, Any]:    """    –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.    Returns:        Dict: –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è    """    try:        import psutil        import os        # –°–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏        process = psutil.Process(os.getpid())        memory_info = process.memory_info()        metrics_data = {            "timestamp": datetime.now().isoformat(),            "uptime_seconds": int((datetime.now() - app_start_time).total_seconds()),            # –°–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏            "system": {                "cpu_percent": process.cpu_percent(),                "memory_rss_mb": round(memory_info.rss / 1024 / 1024, 2),                "memory_vms_mb": round(memory_info.vms / 1024 / 1024, 2),                "open_files": len(process.open_files()),                "threads": process.num_threads()            },            # –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è            "application": {                "total_requests": request_count,                "total_errors": error_count,                "error_rate": round((error_count / max(request_count, 1)) * 100, 2)            },            # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ë–î            "database": {                "status": "connected" if await check_db_health() else "disconnected"            },            # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è            "config": {                "environment": settings.environment,                "debug": settings.debug,                "enabled_providers": getattr(settings, 'get_enabled_proxy_providers', lambda: [])()            }        }        return metrics_data    except ImportError:        # psutil –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω        logger.warning("psutil not available, returning basic metrics")        return {            "timestamp": datetime.now().isoformat(),            "uptime_seconds": int((datetime.now() - app_start_time).total_seconds()),            "application": {                "total_requests": request_count,                "total_errors": error_count,                "error_rate": round((error_count / max(request_count, 1)) * 100, 2)            },            "system": {                "message": "System metrics unavailable (psutil not installed)"            }        }    except Exception as metrics_error:        logger.error(f"Error collecting metrics: {metrics_error}")        return {            "error": "Failed to collect metrics",            "timestamp": datetime.now().isoformat(),            "details": str(metrics_error)        }@app.get("/version", tags=["System"])async def version_info() -> Dict[str, Any]:    """    –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ—Ä—Å–∏–∏ API.    Returns:        Dict: –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ—Ä—Å–∏–∏    """    import sys    return {        "app_name": settings.app_name,        "version": settings.app_version,        "environment": settings.environment,        "build_date": app_start_time.isoformat(),        "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",        "api_prefix": settings.api_prefix,        "features": [            "Authentication",            "User Management",            "Product Catalog",            "Shopping Cart",            "Order Processing",            "Payment Integration",            "Proxy Management"        ]    }# === –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –†–û–£–¢–ï–†–û–í ===# –ü–æ–¥–∫–ª—é—á–∞–µ–º –≤—Å–µ —Ä–æ—É—Ç–µ—Ä—ã —Å –µ–¥–∏–Ω—ã–º –ø—Ä–µ—Ñ–∏–∫—Å–æ–ºapp.include_router(auth.router, prefix=settings.api_prefix, tags=["Authentication"])app.include_router(users.router, prefix=settings.api_prefix, tags=["Users"])app.include_router(products.router, prefix=settings.api_prefix, tags=["Products"])app.include_router(cart.router, prefix=settings.api_prefix, tags=["Cart"])app.include_router(orders.router, prefix=settings.api_prefix, tags=["Orders"])app.include_router(payments.router, prefix=settings.api_prefix, tags=["Payments"])app.include_router(proxies.router, prefix=settings.api_prefix, tags=["Proxies"])logger.info("‚úÖ All routers configured")# === –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï MIDDLEWARE ===@app.middleware("http")async def add_metrics_middleware(request: Request, call_next):    """Middleware –¥–ª—è —Å–±–æ—Ä–∞ –º–µ—Ç—Ä–∏–∫ –∑–∞–ø—Ä–æ—Å–æ–≤."""    global request_count, error_count    request_count += 1    try:        response = await call_next(request)        # –°—á–∏—Ç–∞–µ–º –æ—à–∏–±–∫–∏        if response.status_code >= 400:            error_count += 1        return response    except Exception:        error_count += 1        raise# === EVENT HANDLERS ===@app.exception_handler(404)async def not_found_handler(request: Request, _: StarletteHTTPException):    """–ö–∞—Å—Ç–æ–º–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ 404 –æ—à–∏–±–æ–∫."""    return JSONResponse(        status_code=404,        content={            "error": True,            "message": "Endpoint not found",            "code": "NOT_FOUND",            "path": str(request.url.path),            "available_endpoints": [                f"{settings.api_prefix}/auth",                f"{settings.api_prefix}/users",                f"{settings.api_prefix}/products",                f"{settings.api_prefix}/cart",                f"{settings.api_prefix}/orders",                f"{settings.api_prefix}/payments",                f"{settings.api_prefix}/proxies"            ]        }    )if __name__ == "__main__":    # –î–ª—è –∑–∞–ø—É—Å–∫–∞ –≤ development —Ä–µ–∂–∏–º–µ –Ω–µ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ    import uvicorn    uvicorn.run(        "app.core.main:app",        host="0.0.0.0",        port=8080,        reload=True,        log_level="info"    )