"""Настройка middleware для FastAPI приложения.Включает CORS, безопасность, логирование, сжатие и обработку ошибок."""import loggingimport timeimport uuidfrom fastapi import FastAPI, Requestfrom fastapi.middleware.cors import CORSMiddlewarefrom fastapi.middleware.gzip import GZipMiddlewarefrom fastapi.responses import JSONResponsefrom starlette.middleware.base import BaseHTTPMiddlewarefrom starlette.middleware.sessions import SessionMiddlewarefrom app.core.config import settingslogger = logging.getLogger(__name__)class SecurityHeadersMiddleware(BaseHTTPMiddleware):    """    Middleware для добавления заголовков безопасности.    Автоматически добавляет важные заголовки безопасности ко всем ответам,    с особой обработкой для документации API.    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        # Базовые заголовки безопасности (для всех страниц)        self.base_headers = {            "X-Content-Type-Options": "nosniff",            "X-XSS-Protection": "1; mode=block",            "X-Frame-Options": "DENY",            "Server": "Gemup-API",            "Referrer-Policy": "strict-origin-when-cross-origin",        }        # Строгий CSP для API эндпоинтов        self.api_csp = (            "default-src 'self'; "            "script-src 'self' 'unsafe-inline'; "            "style-src 'self' 'unsafe-inline'; "            "img-src 'self' data: https:; "            "connect-src 'self';"        )        # Более мягкий CSP для документации (разрешаем CDN)        self.docs_csp = (            "default-src 'self' https:; "            "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com; "            "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com; "            "img-src 'self' data: https:; "            "connect-src 'self' https:; "            "font-src 'self' https://cdn.jsdelivr.net https://unpkg.com;"        )    async def dispatch(self, request: Request, call_next):        """Обработка запроса и добавление заголовков безопасности."""        # Получаем ответ от приложения        response = await call_next(request)        # Добавляем базовые заголовки безопасности        for header, value in self.base_headers.items():            response.headers[header] = value        # Определяем CSP в зависимости от пути        path = request.url.path        if path in ["/docs", "/redoc"] or path.startswith("/docs/") or path.startswith("/redoc/"):            # Для документации используем мягкий CSP (разрешаем CDN)            response.headers["Content-Security-Policy"] = self.docs_csp            logger.debug(f"Applied docs CSP for path: {path}")        else:            # Для API используем строгий CSP            response.headers["Content-Security-Policy"] = self.api_csp        # Добавляем HSTS только в production с HTTPS        if settings.is_production():            response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload"        return responseclass RequestLoggingMiddleware(BaseHTTPMiddleware):    """    Middleware для логирования HTTP запросов.    Логирует информацию о каждом запросе включая время обработки,    статус ответа, размер и метаданные клиента.    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        self.exclude_paths = {"/health", "/metrics", "/favicon.ico"}    async def dispatch(self, request: Request, call_next):        """Обработка и логирование запроса."""        # Генерируем уникальный ID запроса        request_id = str(uuid.uuid4())[:8]        # Добавляем ID в контекст запроса        request.state.request_id = request_id        # Получаем информацию о клиенте        client_ip = self._get_client_ip(request)        user_agent = request.headers.get("user-agent", "Unknown")[:100]        # Время начала обработки        start_time = time.perf_counter()        # Логируем начало запроса (если не в исключениях)        if request.url.path not in self.exclude_paths:            logger.info(                f"[{request_id}] {request.method} {request.url.path} - "                f"Client: {client_ip} - User-Agent: {user_agent}..."            )        try:            # Обрабатываем запрос            response = await call_next(request)            # Время обработки            process_time = time.perf_counter() - start_time            # Размер ответа            content_length = response.headers.get("content-length", "unknown")            # Добавляем заголовки            response.headers["X-Request-ID"] = request_id            response.headers["X-Process-Time"] = f"{process_time:.4f}"            # Логируем завершение запроса            if request.url.path not in self.exclude_paths:                logger.info(                    f"[{request_id}] {request.method} {request.url.path} - "                    f"Status: {response.status_code} - Time: {process_time:.4f}s - "                    f"Size: {content_length} bytes"                )            return response        except Exception as exc:            # Время обработки даже при ошибке            process_time = time.perf_counter() - start_time            logger.error(                f"[{request_id}] {request.method} {request.url.path} - "                f"ERROR: {str(exc)} - Time: {process_time:.4f}s"            )            # Создаем ответ с ошибкой            error_response = JSONResponse(                status_code=500,                content={                    "error": True,                    "message": "Internal server error",                    "request_id": request_id                }            )            error_response.headers["X-Request-ID"] = request_id            error_response.headers["X-Process-Time"] = f"{process_time:.4f}"            return error_response    def _get_client_ip(self, request: Request) -> str:        """Получение IP адреса клиента с учетом прокси."""        # Проверяем заголовки прокси        forwarded_for = request.headers.get("X-Forwarded-For")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        real_ip = request.headers.get("X-Real-IP")        if real_ip:            return real_ip        # Возвращаем IP из соединения        if hasattr(request.client, 'host'):            return request.client.host        return "unknown"class RateLimitMiddleware(BaseHTTPMiddleware):    """    Базовая защита от слишком частых запросов.    Простая защита на уровне IP адреса для предотвращения    базовых атак и злоупотреблений.    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        self.requests = {}  # IP -> {"count": int, "reset_time": float}        self.max_requests = settings.rate_limit_requests        self.window_seconds = settings.rate_limit_window    async def dispatch(self, request: Request, call_next):        """Проверка лимитов и обработка запроса."""        client_ip = self._get_client_ip(request)        current_time = time.time()        # Пропускаем health checks        if request.url.path in ["/health", "/metrics"]:            return await call_next(request)        # Проверяем лимиты        if self._is_rate_limited(client_ip, current_time):            logger.warning(f"Rate limit exceeded for IP: {client_ip}")            return JSONResponse(                status_code=429,                content={                    "error": True,                    "message": "Too many requests",                    "code": "RATE_LIMIT_EXCEEDED"                },                headers={                    "Retry-After": str(self.window_seconds),                    "X-RateLimit-Limit": str(self.max_requests),                    "X-RateLimit-Remaining": "0"                }            )        # Обновляем счетчик        self._update_counter(client_ip, current_time)        response = await call_next(request)        # Добавляем заголовки лимитов        remaining = self._get_remaining_requests(client_ip, current_time)        response.headers["X-RateLimit-Limit"] = str(self.max_requests)        response.headers["X-RateLimit-Remaining"] = str(remaining)        return response    def _get_client_ip(self, request: Request) -> str:        """Получение IP адреса клиента."""        forwarded_for = request.headers.get("X-Forwarded-For")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        if hasattr(request.client, 'host'):            return request.client.host        return "unknown"    def _is_rate_limited(self, ip: str, current_time: float) -> bool:        """Проверка превышения лимита."""        if ip not in self.requests:            return False        request_data = self.requests[ip]        # Сброс счетчика если окно истекло        if current_time > request_data["reset_time"]:            del self.requests[ip]            return False        return request_data["count"] >= self.max_requests    def _update_counter(self, ip: str, current_time: float):        """Обновление счетчика запросов."""        if ip not in self.requests:            self.requests[ip] = {                "count": 1,                "reset_time": current_time + self.window_seconds            }        else:            self.requests[ip]["count"] += 1    def _get_remaining_requests(self, ip: str, current_time: float) -> int:        """Получение оставшегося количества запросов."""        if ip not in self.requests:            return self.max_requests        request_data = self.requests[ip]        if current_time > request_data["reset_time"]:            return self.max_requests        return max(0, self.max_requests - request_data["count"])def setup_middleware(app: FastAPI) -> None:    """    Настройка всех middleware для приложения.    Args:        app: Экземпляр FastAPI приложения    """    logger.info("Setting up middleware...")    # 1. CORS - должен быть первым    app.add_middleware(        CORSMiddleware,        allow_origins=settings.cors_origins_list,        allow_credentials=True,        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"],        allow_headers=[            "Accept",            "Accept-Language",            "Content-Language",            "Content-Type",            "Authorization",            "X-Requested-With",            "X-Request-ID",            "User-Agent",            "Referer"        ],        expose_headers=[            "X-Request-ID",            "X-Process-Time",            "X-RateLimit-Limit",            "X-RateLimit-Remaining"        ]    )    logger.info("✅ CORS middleware configured")    # 2. Security Headers    app.add_middleware(SecurityHeadersMiddleware)    logger.info("✅ Security Headers middleware configured")    # 3. GZip сжатие    app.add_middleware(GZipMiddleware, minimum_size=1000)    logger.info("✅ GZip middleware configured")    # 4. Sessions (для гостевых пользователей)    app.add_middleware(        SessionMiddleware,        secret_key=settings.secret_key,        max_age=settings.guest_session_expire_hours * 3600,        same_site="lax",        https_only=settings.is_production()    )    logger.info("✅ Session middleware configured")    # 5. Rate Limiting (только в production)    if settings.is_production():        app.add_middleware(RateLimitMiddleware)        logger.info("✅ Rate Limiting middleware configured")    # 6. Request Logging    app.add_middleware(RequestLoggingMiddleware)    logger.info("✅ Request Logging middleware configured")    logger.info("🚀 All middleware configured successfully")def setup_error_handlers(app: FastAPI) -> None:    """    Настройка обработчиков ошибок.    Args:        app: Экземпляр FastAPI приложения    """    from app.core.exceptions import setup_exception_handlers    setup_exception_handlers(app)    logger.info("✅ Error handlers configured")