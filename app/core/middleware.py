"""Настройка middleware для FastAPI приложения."""import asyncioimport loggingimport timeimport uuidfrom typing import Dict, Listfrom fastapi import FastAPI, Requestfrom fastapi.middleware.cors import CORSMiddlewarefrom fastapi.middleware.gzip import GZipMiddlewarefrom fastapi.responses import JSONResponsefrom starlette.middleware.base import BaseHTTPMiddlewarefrom starlette.middleware.sessions import SessionMiddlewarefrom app.core.config import settingslogger = logging.getLogger(__name__)class SecurityHeadersMiddleware(BaseHTTPMiddleware):    """    Middleware для добавления заголовков безопасности.    ИСПРАВЛЕНИЯ:    ✅ Better error handling для cancelled connections    ✅ Enhanced CSP policies    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        # Базовые заголовки безопасности        self.base_headers = {            "X-Content-Type-Options": "nosniff",            "X-XSS-Protection": "1; mode=block",            "X-Frame-Options": "DENY",            "Server": "Gemup-API",            "Referrer-Policy": "strict-origin-when-cross-origin",            "X-Robots-Tag": "noindex, nofollow",        }        # Строгий CSP для API эндпоинтов        self.api_csp = (            "default-src 'self'; "            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "            "style-src 'self' 'unsafe-inline'; "            "img-src 'self' data: https:; "            "connect-src 'self'; "            "font-src 'self'; "            "object-src 'none'; "            "media-src 'self'; "            "frame-src 'none';"        )        # Более мягкий CSP для документации        self.docs_csp = (            "default-src 'self' https:; "            "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://unpkg.com; "            "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com https://fonts.googleapis.com; "            "img-src 'self' data: https:; "            "connect-src 'self' https:; "            "font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com; "            "object-src 'none';"        )    async def dispatch(self, request: Request, call_next):        """ИСПРАВЛЕНО: Better error handling для cancelled connections."""        try:            # Получаем ответ от приложения            response = await call_next(request)            # Добавляем базовые заголовки безопасности            for header, value in self.base_headers.items():                response.headers[header] = value            # Определяем CSP в зависимости от пути            path = request.url.path.lower()            if any(doc_path in path for doc_path in ["/docs", "/redoc", "/openapi.json"]):                response.headers["Content-Security-Policy"] = self.docs_csp            else:                response.headers["Content-Security-Policy"] = self.api_csp            # HSTS только в production с HTTPS            if settings.is_production():                response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload"            return response        except Exception as e:            # ИСПРАВЛЕНИЕ: Proper handling для cancelled connections            logger.debug(f"Security middleware error (likely cancelled connection): {e}")            # Не создаем response здесь - пусть обрабатывает верхний уровень            raiseclass EnhancedRequestLoggingMiddleware(BaseHTTPMiddleware):    """    ИСПРАВЛЕННЫЙ middleware для логирования HTTP запросов.    КРИТИЧЕСКИЕ ИСПРАВЛЕНИЯ:    ✅ Proper error handling для cancelled connections    ✅ No response creation in middleware (prevents "No response returned" errors)    ✅ Better logging performance    ✅ Request ID propagation    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        self.exclude_paths = {"/health", "/metrics", "/favicon.ico", "/robots.txt"}    async def dispatch(self, request: Request, call_next):        """ИСПРАВЛЕНО: No response creation, proper error propagation."""        # Генерируем уникальный ID запроса        request_id = str(uuid.uuid4())[:8]        request.state.request_id = request_id        # Информация о клиенте        client_ip = self._get_client_ip(request)        user_agent = request.headers.get("user-agent", "Unknown")[:100]        # Время начала        start_time = time.perf_counter()        # Логируем начало запроса (если не в исключениях)        should_log = request.url.path not in self.exclude_paths        if should_log:            logger.info(                f"[{request_id}] {request.method} {request.url.path} - "                f"Client: {client_ip} - User-Agent: {user_agent}..."            )        try:            # ИСПРАВЛЕНИЕ: Не создаем response при ошибке - просто propagate исключение            response = await call_next(request)            # Время обработки            process_time = time.perf_counter() - start_time            # Добавляем заголовки            response.headers["X-Request-ID"] = request_id            response.headers["X-Process-Time"] = f"{process_time:.4f}"            # Логируем успешное завершение            if should_log:                content_length = response.headers.get("content-length", "unknown")                logger.info(                    f"[{request_id}] {request.method} {request.url.path} - "                    f"Status: {response.status_code} - Time: {process_time:.4f}s - "                    f"Size: {content_length} bytes"                )            return response        except Exception as exc:            # ИСПРАВЛЕНИЕ: Логируем ошибку но НЕ создаем response            process_time = time.perf_counter() - start_time            # Логируем только если это не cancelled connection            if not isinstance(exc, (asyncio.CancelledError, ConnectionResetError)):                logger.error(                    f"[{request_id}] {request.method} {request.url.path} - "                    f"ERROR: {str(exc)[:100]} - Time: {process_time:.4f}s"                )            else:                logger.debug(f"[{request_id}] Connection cancelled/reset")            # ИСПРАВЛЕНИЕ: Просто re-raise исключение, не создаем response            raise    @staticmethod    def _get_client_ip(request: Request) -> str:        """Получение IP адреса клиента с учетом прокси."""        # Проверяем заголовки прокси        forwarded_for = request.headers.get("X-Forwarded-For")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        real_ip = request.headers.get("X-Real-IP")        if real_ip:            return real_ip        cloudflare_ip = request.headers.get("CF-Connecting-IP")        if cloudflare_ip:            return cloudflare_ip        # Возвращаем IP из соединения        if hasattr(request.client, 'host') and request.client.host:            return request.client.host        return "unknown"class EnhancedRateLimitMiddleware(BaseHTTPMiddleware):    """    ИСПРАВЛЕННЫЙ Rate limiting middleware с thread safety и memory management.    КРИТИЧЕСКИЕ ИСПРАВЛЕНИЯ:    ✅ Thread safety с asyncio.Lock    ✅ Automatic cleanup для предотвращения memory leaks    ✅ Sliding window algorithm    ✅ Enhanced error handling    ✅ IP whitelist support    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        # Конфигурация        self.max_requests = settings.rate_limit_requests        self.window_seconds = settings.rate_limit_window        # ИСПРАВЛЕНИЕ: Thread-safe хранилище        self._requests: Dict[str, Dict] = {}        self._lock = asyncio.Lock()        # Последняя очистка        self._last_cleanup = time.time()        self._cleanup_interval = 300  # 5 минут        # IP whitelist для внутренних сервисов        self._whitelist_ips = {            "127.0.0.1", "::1", "localhost",            "172.17.0.1",  # Docker gateway        }        # Exclude paths        self._exclude_paths = {"/health", "/metrics", "/docs", "/redoc", "/openapi.json"}    async def dispatch(self, request: Request, call_next):        """ИСПРАВЛЕНО: Thread-safe rate limiting с auto cleanup."""        path = request.url.path        # Пропускаем исключенные пути        if path in self._exclude_paths:            return await call_next(request)        client_ip = self._get_client_ip(request)        current_time = time.time()        # Пропускаем whitelisted IP        if client_ip in self._whitelist_ips:            return await call_next(request)        # ИСПРАВЛЕНИЕ: Thread-safe проверка и обновление        async with self._lock:            # Периодическая очистка для предотвращения memory leak            if current_time - self._last_cleanup > self._cleanup_interval:                await self._cleanup_expired_entries(current_time)                self._last_cleanup = current_time            # Проверяем rate limit            if await self._is_rate_limited(client_ip, current_time):                remaining_time = await self._get_reset_time(client_ip, current_time)                logger.warning(f"Rate limit exceeded for IP: {client_ip}")                return JSONResponse(                    status_code=429,                    content={                        "error": True,                        "message": "Too many requests. Please try again later.",                        "code": "RATE_LIMIT_EXCEEDED",                        "retry_after": int(remaining_time)                    },                    headers={                        "Retry-After": str(int(remaining_time)),                        "X-RateLimit-Limit": str(self.max_requests),                        "X-RateLimit-Remaining": "0",                        "X-RateLimit-Reset": str(int(current_time + remaining_time))                    }                )            # Обновляем счетчик            await self._update_counter(client_ip, current_time)        # Обрабатываем запрос        response = await call_next(request)        # Добавляем rate limit заголовки        async with self._lock:            remaining = await self._get_remaining_requests(client_ip, current_time)            reset_time = await self._get_reset_time(client_ip, current_time)        response.headers["X-RateLimit-Limit"] = str(self.max_requests)        response.headers["X-RateLimit-Remaining"] = str(remaining)        response.headers["X-RateLimit-Reset"] = str(int(current_time + reset_time))        return response    @staticmethod    def _get_client_ip(request: Request) -> str:        """Получение IP адреса клиента."""        # Проверяем заголовки прокси в правильном порядке        for header in ["CF-Connecting-IP", "X-Forwarded-For", "X-Real-IP"]:            ip = request.headers.get(header)            if ip:                return ip.split(",")[0].strip()        if hasattr(request.client, 'host') and request.client.host:            return request.client.host        return "unknown"    async def _is_rate_limited(self, ip: str, current_time: float) -> bool:        """Thread-safe проверка rate limit."""        if ip not in self._requests:            return False        request_data = self._requests[ip]        # Sliding window: удаляем старые запросы        cutoff_time = current_time - self.window_seconds        request_data["timestamps"] = [            ts for ts in request_data["timestamps"]            if ts > cutoff_time        ]        return len(request_data["timestamps"]) >= self.max_requests    async def _update_counter(self, ip: str, current_time: float):        """Thread-safe обновление счетчика."""        if ip not in self._requests:            self._requests[ip] = {                "timestamps": [],                "created_at": current_time            }        # Добавляем текущий timestamp        self._requests[ip]["timestamps"].append(current_time)        # Оставляем только актуальные timestamps        cutoff_time = current_time - self.window_seconds        self._requests[ip]["timestamps"] = [            ts for ts in self._requests[ip]["timestamps"]            if ts > cutoff_time        ]    async def _get_remaining_requests(self, ip: str, current_time: float) -> int:        """Получение оставшегося количества запросов."""        if ip not in self._requests:            return self.max_requests        cutoff_time = current_time - self.window_seconds        valid_requests = [            ts for ts in self._requests[ip]["timestamps"]            if ts > cutoff_time        ]        return max(0, self.max_requests - len(valid_requests))    async def _get_reset_time(self, ip: str, current_time: float) -> float:        """Получение времени до сброса лимита."""        if ip not in self._requests or not self._requests[ip]["timestamps"]:            return 0        oldest_request = min(self._requests[ip]["timestamps"])        reset_time = oldest_request + self.window_seconds - current_time        return max(0, reset_time)    async def _cleanup_expired_entries(self, current_time: float):        """ИСПРАВЛЕНИЕ: Automatic cleanup для предотвращения memory leaks."""        cutoff_time = current_time - (self.window_seconds * 2)  # Double window для safety        expired_ips = []        for ip, data in self._requests.items():            # Удаляем старые timestamps            data["timestamps"] = [                ts for ts in data["timestamps"]                if ts > cutoff_time            ]            # Если нет актуальных timestamps, помечаем IP для удаления            if not data["timestamps"] and data["created_at"] < cutoff_time:                expired_ips.append(ip)        # Удаляем expired IPs        for ip in expired_ips:            del self._requests[ip]        if expired_ips:            logger.debug(f"Cleaned up {len(expired_ips)} expired rate limit entries")def get_cors_origins() -> List[str]:    """    ИСПРАВЛЕННАЯ функция получения CORS origins.    ИСПРАВЛЕНИЯ:    ✅ No duplicates    ✅ Better environment handling    ✅ Validation of origins    """    cors_origins = set()  # Use set to avoid duplicates    # В development - добавляем стандартные development origins    if settings.is_development() or settings.debug:        development_origins = {            "http://localhost:3000",    # React/Next.js dev server            "http://localhost:3001",            "http://127.0.0.1:3000",            "http://127.0.0.1:3001",            "http://localhost:8080",    # Vue dev server            "http://localhost:8081",            "http://localhost:4200",    # Angular dev server            "http://localhost:5173",    # Vite dev server            "http://localhost:5174",            "http://localhost:8000",    # FastAPI dev server            "http://localhost:8001",        }        cors_origins.update(development_origins)    # Добавляем origins из настроек    if hasattr(settings, 'cors_origins_list') and settings.cors_origins_list:        cors_origins.update(settings.cors_origins_list)    # Frontend URL из настроек    if hasattr(settings, 'frontend_url') and settings.frontend_url:        cors_origins.add(settings.frontend_url)    # Base URL из настроек    if hasattr(settings, 'base_url') and settings.base_url:        cors_origins.add(settings.base_url)    # В production добавляем production домены    if settings.is_production():        production_origins = {            "https://yourdomain.com",            "https://www.yourdomain.com",            "https://api.yourdomain.com"        }        cors_origins.update(production_origins)    # Фильтруем и валидируем origins    valid_origins = []    for origin in cors_origins:        if origin and isinstance(origin, str) and origin.strip():            cleaned_origin = origin.strip().rstrip('/')            if cleaned_origin.startswith(('http://', 'https://')):                valid_origins.append(cleaned_origin)    return valid_originsdef setup_middleware(app: FastAPI) -> None:    """    ИСПРАВЛЕННАЯ настройка всех middleware.    ИСПРАВЛЕНИЯ:    ✅ Proper order для middleware    ✅ Enhanced error handling    ✅ Better configuration    """    logger.info("🔧 Setting up security-focused middleware...")    # Получаем и валидируем CORS origins    cors_origins = get_cors_origins()    logger.info(f"🌐 CORS Origins ({len(cors_origins)}): {', '.join(cors_origins[:5])}{'...' if len(cors_origins) > 5 else ''}")    # 1. CORS (должен быть первым для preflight requests)    app.add_middleware(        CORSMiddleware,        allow_origins=cors_origins,        allow_credentials=True,        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"],        allow_headers=[            "Accept",            "Accept-Language",            "Content-Language",            "Content-Type",            "Authorization",            "X-Requested-With",            "X-Request-ID",            "X-Session-ID",            "User-Agent",            "Referer",            "Origin",            "Access-Control-Request-Method",            "Access-Control-Request-Headers",            "Cache-Control",            "Pragma"        ],        expose_headers=[            "X-Request-ID",            "X-Process-Time",            "X-RateLimit-Limit",            "X-RateLimit-Remaining",            "X-RateLimit-Reset",            "Content-Disposition",            "Content-Type",            "Content-Length"        ]    )    logger.info("✅ Secure CORS middleware configured")    # 2. Request Validation (раннее выявление проблем)    @app.middleware("http")    async def request_validation_middleware(request: Request, call_next):        """Basic request validation."""        # Проверяем размер Content-Length        content_length = request.headers.get("content-length")        if content_length and int(content_length) > 10_000_000:  # 10MB limit            return JSONResponse(                status_code=413,                content={"error": True, "message": "Request entity too large"}            )        return await call_next(request)    logger.info("✅ Request Validation middleware configured")    # 3. Security Headers    app.add_middleware(SecurityHeadersMiddleware)    logger.info("✅ Enhanced Security Headers middleware configured")    # 4. Rate Limiting (в production или если явно включено)    if settings.is_production() or getattr(settings, 'enable_rate_limiting', False):        app.add_middleware(EnhancedRateLimitMiddleware)        logger.info("✅ Enhanced Rate Limiting middleware configured")    else:        logger.info("⚠️ Rate Limiting disabled in debug mode")    # 5. GZip сжатие    app.add_middleware(GZipMiddleware, minimum_size=500)    logger.info("✅ GZip compression middleware configured")    # 6. Sessions (для гостевых пользователей)    app.add_middleware(        SessionMiddleware,        secret_key=settings.secret_key,        max_age=settings.guest_session_expire_hours * 3600,        same_site="lax",        https_only=settings.is_production(),        session_cookie="gemup_session"    )    logger.info("✅ Session middleware configured")    # 7. Request Logging (последний для полного контекста)    app.add_middleware(EnhancedRequestLoggingMiddleware)    logger.info("✅ Enhanced Request Logging middleware configured")    logger.info("🚀 All middleware configured successfully with security focus")def setup_error_handlers(app: FastAPI) -> None:    """    Настройка обработчиков ошибок.    Args:        app: Экземпляр FastAPI приложения    """    from app.core.exceptions import setup_exception_handlers    setup_exception_handlers(app)    logger.info("✅ Error handlers configured")