"""Настройка middleware для приложения FastAPI.Содержит конфигурацию всех middleware компонентов:CORS, сжатие, сессии, безопасность и кастомные middleware."""import loggingimport timeimport uuidfrom typing import Callablefrom fastapi import FastAPI, Request, Responsefrom fastapi.middleware.cors import CORSMiddlewarefrom fastapi.middleware.trustedhost import TrustedHostMiddlewarefrom starlette.middleware.base import BaseHTTPMiddlewarefrom starlette.middleware.gzip import GZipMiddlewarefrom starlette.middleware.sessions import SessionMiddlewarefrom starlette.types import ASGIAppfrom app.core.config import settingslogger = logging.getLogger(__name__)class RequestLoggingMiddleware(BaseHTTPMiddleware):    """    Middleware для логирования HTTP запросов.    Записывает информацию о каждом запросе включая:    - Метод и путь    - Время выполнения    - Статус ответа    - IP адрес клиента    - User Agent    """    async def dispatch(self, request: Request, call_next: Callable) -> Response:        """        Обработка HTTP запроса с логированием.        Args:            request: Входящий HTTP запрос            call_next: Следующий обработчик в цепочке        Returns:            Response: HTTP ответ        """        # Генерируем уникальный ID запроса        request_id = str(uuid.uuid4())[:8]        # Добавляем ID запроса в контекст        request.state.request_id = request_id        # Получаем информацию о клиенте        client_ip = self._get_client_ip(request)        user_agent = request.headers.get("user-agent", "Unknown")        # Засекаем время начала        start_time = time.time()        logger.info(            f"[{request_id}] {request.method} {request.url.path} - "            f"Client: {client_ip} - "            f"User-Agent: {user_agent[:100]}..."        )        try:            # Выполняем запрос            response = await call_next(request)            # Вычисляем время выполнения            process_time = time.time() - start_time            # Логируем результат            logger.info(                f"[{request_id}] {request.method} {request.url.path} - "                f"Status: {response.status_code} - "                f"Time: {process_time:.4f}s - "                f"Size: {response.headers.get('content-length', 'unknown')} bytes"            )            # Добавляем заголовки ответа            response.headers["X-Request-ID"] = request_id            response.headers["X-Process-Time"] = f"{process_time:.4f}"            return response        except Exception as e:            # Логируем ошибки            process_time = time.time() - start_time            logger.error(                f"[{request_id}] {request.method} {request.url.path} - "                f"ERROR: {str(e)} - "                f"Time: {process_time:.4f}s"            )            raise    def _get_client_ip(self, request: Request) -> str:        """        Получение IP адреса клиента с учетом прокси.        Args:            request: HTTP запрос        Returns:            str: IP адрес клиента        """        # Проверяем заголовки прокси        forwarded_for = request.headers.get("x-forwarded-for")        if forwarded_for:            # Берем первый IP из списка            return forwarded_for.split(",")[0].strip()        real_ip = request.headers.get("x-real-ip")        if real_ip:            return real_ip        # Fallback на стандартный клиентский IP        if request.client:            return request.client.host        return "unknown"class SecurityHeadersMiddleware(BaseHTTPMiddleware):    """    Middleware для добавления заголовков безопасности.    Добавляет стандартные заголовки безопасности для защиты от    различных типов атак и повышения общей безопасности.    """    async def dispatch(self, request: Request, call_next: Callable) -> Response:        """        Добавление заголовков безопасности к ответу.        Args:            request: HTTP запрос            call_next: Следующий обработчик        Returns:            Response: HTTP ответ с заголовками безопасности        """        response = await call_next(request)        # Заголовки безопасности        security_headers = {            # Предотвращает MIME type sniffing            "X-Content-Type-Options": "nosniff",            # Защита от XSS            "X-XSS-Protection": "1; mode=block",            # Предотвращает загрузку в iframe (clickjacking)            "X-Frame-Options": "DENY",            # Удаляем информацию о сервере            "Server": "Gemup-API",            # Referrer Policy            "Referrer-Policy": "strict-origin-when-cross-origin"        }        # Content Security Policy (только для HTML ответов)        if response.headers.get("content-type", "").startswith("text/html"):            security_headers["Content-Security-Policy"] = (                "default-src 'self'; "                "script-src 'self' 'unsafe-inline'; "                "style-src 'self' 'unsafe-inline'; "                "img-src 'self' data: https:; "                "connect-src 'self';"            )        # HSTS для HTTPS (только в production)        if settings.is_production() and request.url.scheme == "https":            security_headers["Strict-Transport-Security"] = (                "max-age=31536000; includeSubDomains; preload"            )        # Добавляем заголовки к ответу        for header, value in security_headers.items():            response.headers[header] = value        return responseclass RateLimitMiddleware(BaseHTTPMiddleware):    """    Middleware для ограничения частоты запросов.    Реализует базовое rate limiting на основе IP адресов    с использованием Redis для хранения счетчиков.    """    def __init__(self, app: ASGIApp, requests_per_minute: int = 60):        """        Инициализация middleware.        Args:            app: ASGI приложение            requests_per_minute: Максимальное количество запросов в минуту        """        super().__init__(app)        self.requests_per_minute = requests_per_minute    async def dispatch(self, request: Request, call_next: Callable) -> Response:        """        Проверка ограничений частоты запросов.        Args:            request: HTTP запрос            call_next: Следующий обработчик        Returns:            Response: HTTP ответ или ошибка 429        """        from app.core.redis import redis_client        from fastapi import status        # Пропускаем rate limiting для определенных путей        excluded_paths = ["/health", "/metrics", "/docs", "/redoc", "/openapi.json"]        if any(request.url.path.startswith(path) for path in excluded_paths):            return await call_next(request)        # Получаем идентификатор клиента        client_ip = self._get_client_ip(request)        try:            # Проверяем rate limit через Redis            allowed = await redis_client.rate_limit_check(                identifier=f"rate_limit:{client_ip}",                limit=self.requests_per_minute,                window_seconds=60            )            if not allowed:                logger.warning(f"Rate limit exceeded for IP: {client_ip}")                # Создаем ответ 429                from fastapi.responses import JSONResponse                return JSONResponse(                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,                    content={                        "error": True,                        "message": "Rate limit exceeded",                        "code": "RATE_LIMIT_ERROR",                        "retry_after": 60                    },                    headers={"Retry-After": "60"}                )        except Exception as e:            # В случае ошибки Redis разрешаем запрос            logger.error(f"Rate limit check failed: {e}")        return await call_next(request)    def _get_client_ip(self, request: Request) -> str:        """Получение IP адреса клиента."""        forwarded_for = request.headers.get("x-forwarded-for")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        if request.client:            return request.client.host        return "unknown"def setup_middleware(app: FastAPI) -> None:    """    Настройка всех middleware для приложения FastAPI.    Порядок добавления middleware важен - они выполняются в обратном порядке.    Args:        app: Экземпляр FastAPI приложения    """    logger.info("Setting up middleware...")    # 1. CORS middleware (должен быть первым)    app.add_middleware(        CORSMiddleware,        allow_origins=settings.cors_origins_list,        allow_credentials=True,        allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"],        allow_headers=["*"],        expose_headers=["X-Request-ID", "X-Process-Time"]    )    logger.info("✅ CORS middleware configured")    # 2. Trusted Host middleware (только в production)    if settings.is_production():        # В production укажите реальные домены        allowed_hosts = [            "api.gemup.com",            "*.gemup.com",            "gemup.com"        ]        app.add_middleware(            TrustedHostMiddleware,            allowed_hosts=allowed_hosts        )        logger.info("✅ Trusted Host middleware configured for production")    # 3. Security Headers middleware    app.add_middleware(SecurityHeadersMiddleware)    logger.info("✅ Security Headers middleware configured")    # 4. GZip compression middleware    app.add_middleware(        GZipMiddleware,        minimum_size=1000,  # Сжимать ответы больше 1KB        compresslevel=6  # Уровень сжатия (1-9)    )    logger.info("✅ GZip middleware configured")    # 5. Session middleware    app.add_middleware(        SessionMiddleware,        secret_key=settings.secret_key,        max_age=settings.cache_session_ttl,        same_site="lax",        https_only=settings.is_production()    )    logger.info("✅ Session middleware configured")    # 6. Rate Limiting middleware (только в production)    if settings.is_production():        app.add_middleware(            RateLimitMiddleware,            requests_per_minute=settings.rate_limit_requests        )        logger.info("✅ Rate Limiting middleware configured")    # 7. Request Logging middleware (должен быть последним)    app.add_middleware(RequestLoggingMiddleware)    logger.info("✅ Request Logging middleware configured")    logger.info("🚀 All middleware configured successfully")def setup_error_handlers(app: FastAPI) -> None:    """    Настройка обработчиков ошибок.    Args:        app: Экземпляр FastAPI приложения    """    from app.core.exceptions import setup_exception_handlers    setup_exception_handlers(app)    logger.info("✅ Error handlers configured")def add_custom_middleware(app: FastAPI, middleware_class, **kwargs) -> None:    """    Добавление кастомного middleware.    Args:        app: Экземпляр FastAPI приложения        middleware_class: Класс middleware        **kwargs: Дополнительные параметры    """    app.add_middleware(middleware_class, **kwargs)    logger.info(f"✅ Custom middleware {middleware_class.__name__} added")# Дополнительные utility функции для middlewaredef get_request_id(request: Request) -> str:    """    Получение ID запроса из состояния запроса.    Args:        request: HTTP запрос    Returns:        str: Уникальный ID запроса    """    return getattr(request.state, "request_id", "unknown")def is_health_check(request: Request) -> bool:    """    Проверка является ли запрос health check.    Args:        request: HTTP запрос    Returns:        bool: True если это health check    """    health_paths = ["/health", "/healthz", "/status", "/ping"]    return request.url.path in health_pathsdef is_static_file(request: Request) -> bool:    """    Проверка является ли запрос к статическому файлу.    Args:        request: HTTP запрос    Returns:        bool: True если это статический файл    """    static_extensions = [".css", ".js", ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg"]    return any(request.url.path.endswith(ext) for ext in static_extensions)def get_user_agent_info(request: Request) -> dict:    """    Парсинг информации из User-Agent.    Args:        request: HTTP запрос    Returns:        dict: Информация о браузере и ОС    """    user_agent = request.headers.get("user-agent", "")    # Простой парсинг (можно использовать библиотеку user-agents для более точного)    info = {        "full": user_agent,        "is_mobile": "Mobile" in user_agent or "Android" in user_agent,        "is_bot": any(bot in user_agent.lower() for bot in ["bot", "crawler", "spider"]),        "browser": "unknown",        "os": "unknown"    }    # Определение браузера    if "Chrome" in user_agent:        info["browser"] = "Chrome"    elif "Firefox" in user_agent:        info["browser"] = "Firefox"    elif "Safari" in user_agent:        info["browser"] = "Safari"    elif "Edge" in user_agent:        info["browser"] = "Edge"    # Определение ОС    if "Windows" in user_agent:        info["os"] = "Windows"    elif "Mac" in user_agent:        info["os"] = "macOS"    elif "Linux" in user_agent:        info["os"] = "Linux"    elif "Android" in user_agent:        info["os"] = "Android"    elif "iOS" in user_agent:        info["os"] = "iOS"    return info