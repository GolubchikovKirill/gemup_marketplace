"""–ù–∞—Å—Ç—Ä–æ–π–∫–∞ middleware –¥–ª—è FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è."""import asyncioimport loggingimport timeimport uuidfrom typing import Dict, Listfrom fastapi import FastAPI, Requestfrom fastapi.middleware.cors import CORSMiddlewarefrom fastapi.middleware.gzip import GZipMiddlewarefrom fastapi.responses import JSONResponsefrom starlette.middleware.base import BaseHTTPMiddlewarefrom starlette.middleware.sessions import SessionMiddlewarefrom app.core.config import settingslogger = logging.getLogger(__name__)class SecurityHeadersMiddleware(BaseHTTPMiddleware):    """    Middleware –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.    –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:    ‚úÖ Better error handling –¥–ª—è cancelled connections    ‚úÖ Enhanced CSP policies    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        # –ë–∞–∑–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏        self.base_headers = {            "X-Content-Type-Options": "nosniff",            "X-XSS-Protection": "1; mode=block",            "X-Frame-Options": "DENY",            "Server": "Gemup-API",            "Referrer-Policy": "strict-origin-when-cross-origin",            "X-Robots-Tag": "noindex, nofollow",        }        # –°—Ç—Ä–æ–≥–∏–π CSP –¥–ª—è API —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤        self.api_csp = (            "default-src 'self'; "            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "            "style-src 'self' 'unsafe-inline'; "            "img-src 'self' data: https:; "            "connect-src 'self'; "            "font-src 'self'; "            "object-src 'none'; "            "media-src 'self'; "            "frame-src 'none';"        )        # –ë–æ–ª–µ–µ –º—è–≥–∫–∏–π CSP –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏        self.docs_csp = (            "default-src 'self' https:; "            "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://unpkg.com; "            "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com https://fonts.googleapis.com; "            "img-src 'self' data: https:; "            "connect-src 'self' https:; "            "font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com; "            "object-src 'none';"        )    async def dispatch(self, request: Request, call_next):        """–ò–°–ü–†–ê–í–õ–ï–ù–û: Better error handling –¥–ª—è cancelled connections."""        try:            # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è            response = await call_next(request)            # –î–æ–±–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏            for header, value in self.base_headers.items():                response.headers[header] = value            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º CSP –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—É—Ç–∏            path = request.url.path.lower()            if any(doc_path in path for doc_path in ["/docs", "/redoc", "/openapi.json"]):                response.headers["Content-Security-Policy"] = self.docs_csp            else:                response.headers["Content-Security-Policy"] = self.api_csp            # HSTS —Ç–æ–ª—å–∫–æ –≤ production —Å HTTPS            if settings.is_production():                response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload"            return response        except Exception as e:            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Proper handling –¥–ª—è cancelled connections            logger.debug(f"Security middleware error (likely cancelled connection): {e}")            # –ù–µ —Å–æ–∑–¥–∞–µ–º response –∑–¥–µ—Å—å - –ø—É—Å—Ç—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–µ—Ä—Ö–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å            raiseclass EnhancedRequestLoggingMiddleware(BaseHTTPMiddleware):    """    –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è HTTP –∑–∞–ø—Ä–æ—Å–æ–≤.    –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:    ‚úÖ Proper error handling –¥–ª—è cancelled connections    ‚úÖ No response creation in middleware (prevents "No response returned" errors)    ‚úÖ Better logging performance    ‚úÖ Request ID propagation    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        self.exclude_paths = {"/health", "/metrics", "/favicon.ico", "/robots.txt"}    async def dispatch(self, request: Request, call_next):        """–ò–°–ü–†–ê–í–õ–ï–ù–û: No response creation, proper error propagation."""        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –∑–∞–ø—Ä–æ—Å–∞        request_id = str(uuid.uuid4())[:8]        request.state.request_id = request_id        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–ª–∏–µ–Ω—Ç–µ        client_ip = self._get_client_ip(request)        user_agent = request.headers.get("user-agent", "Unknown")[:100]        # –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞        start_time = time.perf_counter()        # –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ –∑–∞–ø—Ä–æ—Å–∞ (–µ—Å–ª–∏ –Ω–µ –≤ –∏—Å–∫–ª—é—á–µ–Ω–∏—è—Ö)        should_log = request.url.path not in self.exclude_paths        if should_log:            logger.info(                f"[{request_id}] {request.method} {request.url.path} - "                f"Client: {client_ip} - User-Agent: {user_agent}..."            )        try:            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ù–µ —Å–æ–∑–¥–∞–µ–º response –ø—Ä–∏ –æ—à–∏–±–∫–µ - –ø—Ä–æ—Å—Ç–æ propagate –∏—Å–∫–ª—é—á–µ–Ω–∏–µ            response = await call_next(request)            # –í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏            process_time = time.perf_counter() - start_time            # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏            response.headers["X-Request-ID"] = request_id            response.headers["X-Process-Time"] = f"{process_time:.4f}"            # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ            if should_log:                content_length = response.headers.get("content-length", "unknown")                logger.info(                    f"[{request_id}] {request.method} {request.url.path} - "                    f"Status: {response.status_code} - Time: {process_time:.4f}s - "                    f"Size: {content_length} bytes"                )            return response        except Exception as exc:            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –Ω–æ –ù–ï —Å–æ–∑–¥–∞–µ–º response            process_time = time.perf_counter() - start_time            # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ cancelled connection            if not isinstance(exc, (asyncio.CancelledError, ConnectionResetError)):                logger.error(                    f"[{request_id}] {request.method} {request.url.path} - "                    f"ERROR: {str(exc)[:100]} - Time: {process_time:.4f}s"                )            else:                logger.debug(f"[{request_id}] Connection cancelled/reset")            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ—Å—Ç–æ re-raise –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –Ω–µ —Å–æ–∑–¥–∞–µ–º response            raise    @staticmethod    def _get_client_ip(request: Request) -> str:        """–ü–æ–ª—É—á–µ–Ω–∏–µ IP –∞–¥—Ä–µ—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞ —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∫—Å–∏."""        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø—Ä–æ–∫—Å–∏        forwarded_for = request.headers.get("X-Forwarded-For")        if forwarded_for:            return forwarded_for.split(",")[0].strip()        real_ip = request.headers.get("X-Real-IP")        if real_ip:            return real_ip        cloudflare_ip = request.headers.get("CF-Connecting-IP")        if cloudflare_ip:            return cloudflare_ip        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º IP –∏–∑ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è        if hasattr(request.client, 'host') and request.client.host:            return request.client.host        return "unknown"class EnhancedRateLimitMiddleware(BaseHTTPMiddleware):    """    –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô Rate limiting middleware —Å thread safety –∏ memory management.    –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:    ‚úÖ Thread safety —Å asyncio.Lock    ‚úÖ Automatic cleanup –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è memory leaks    ‚úÖ Sliding window algorithm    ‚úÖ Enhanced error handling    ‚úÖ IP whitelist support    """    def __init__(self, app, **kwargs):        super().__init__(app, **kwargs)        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è        self.max_requests = settings.rate_limit_requests        self.window_seconds = settings.rate_limit_window        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Thread-safe —Ö—Ä–∞–Ω–∏–ª–∏—â–µ        self._requests: Dict[str, Dict] = {}        self._lock = asyncio.Lock()        # –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—á–∏—Å—Ç–∫–∞        self._last_cleanup = time.time()        self._cleanup_interval = 300  # 5 –º–∏–Ω—É—Ç        # IP whitelist –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤        self._whitelist_ips = {            "127.0.0.1", "::1", "localhost",            "172.17.0.1",  # Docker gateway        }        # Exclude paths        self._exclude_paths = {"/health", "/metrics", "/docs", "/redoc", "/openapi.json"}    async def dispatch(self, request: Request, call_next):        """–ò–°–ü–†–ê–í–õ–ï–ù–û: Thread-safe rate limiting —Å auto cleanup."""        path = request.url.path        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø—É—Ç–∏        if path in self._exclude_paths:            return await call_next(request)        client_ip = self._get_client_ip(request)        current_time = time.time()        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º whitelisted IP        if client_ip in self._whitelist_ips:            return await call_next(request)        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Thread-safe –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ        async with self._lock:            # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è memory leak            if current_time - self._last_cleanup > self._cleanup_interval:                await self._cleanup_expired_entries(current_time)                self._last_cleanup = current_time            # –ü—Ä–æ–≤–µ—Ä—è–µ–º rate limit            if await self._is_rate_limited(client_ip, current_time):                remaining_time = await self._get_reset_time(client_ip, current_time)                logger.warning(f"Rate limit exceeded for IP: {client_ip}")                return JSONResponse(                    status_code=429,                    content={                        "error": True,                        "message": "Too many requests. Please try again later.",                        "code": "RATE_LIMIT_EXCEEDED",                        "retry_after": int(remaining_time)                    },                    headers={                        "Retry-After": str(int(remaining_time)),                        "X-RateLimit-Limit": str(self.max_requests),                        "X-RateLimit-Remaining": "0",                        "X-RateLimit-Reset": str(int(current_time + remaining_time))                    }                )            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫            await self._update_counter(client_ip, current_time)        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å        response = await call_next(request)        # –î–æ–±–∞–≤–ª—è–µ–º rate limit –∑–∞–≥–æ–ª–æ–≤–∫–∏        async with self._lock:            remaining = await self._get_remaining_requests(client_ip, current_time)            reset_time = await self._get_reset_time(client_ip, current_time)        response.headers["X-RateLimit-Limit"] = str(self.max_requests)        response.headers["X-RateLimit-Remaining"] = str(remaining)        response.headers["X-RateLimit-Reset"] = str(int(current_time + reset_time))        return response    @staticmethod    def _get_client_ip(request: Request) -> str:        """–ü–æ–ª—É—á–µ–Ω–∏–µ IP –∞–¥—Ä–µ—Å–∞ –∫–ª–∏–µ–Ω—Ç–∞."""        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø—Ä–æ–∫—Å–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ        for header in ["CF-Connecting-IP", "X-Forwarded-For", "X-Real-IP"]:            ip = request.headers.get(header)            if ip:                return ip.split(",")[0].strip()        if hasattr(request.client, 'host') and request.client.host:            return request.client.host        return "unknown"    async def _is_rate_limited(self, ip: str, current_time: float) -> bool:        """Thread-safe –ø—Ä–æ–≤–µ—Ä–∫–∞ rate limit."""        if ip not in self._requests:            return False        request_data = self._requests[ip]        # Sliding window: —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø—Ä–æ—Å—ã        cutoff_time = current_time - self.window_seconds        request_data["timestamps"] = [            ts for ts in request_data["timestamps"]            if ts > cutoff_time        ]        return len(request_data["timestamps"]) >= self.max_requests    async def _update_counter(self, ip: str, current_time: float):        """Thread-safe –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞."""        if ip not in self._requests:            self._requests[ip] = {                "timestamps": [],                "created_at": current_time            }        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π timestamp        self._requests[ip]["timestamps"].append(current_time)        # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ timestamps        cutoff_time = current_time - self.window_seconds        self._requests[ip]["timestamps"] = [            ts for ts in self._requests[ip]["timestamps"]            if ts > cutoff_time        ]    async def _get_remaining_requests(self, ip: str, current_time: float) -> int:        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–∞–ø—Ä–æ—Å–æ–≤."""        if ip not in self._requests:            return self.max_requests        cutoff_time = current_time - self.window_seconds        valid_requests = [            ts for ts in self._requests[ip]["timestamps"]            if ts > cutoff_time        ]        return max(0, self.max_requests - len(valid_requests))    async def _get_reset_time(self, ip: str, current_time: float) -> float:        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ —Å–±—Ä–æ—Å–∞ –ª–∏–º–∏—Ç–∞."""        if ip not in self._requests or not self._requests[ip]["timestamps"]:            return 0        oldest_request = min(self._requests[ip]["timestamps"])        reset_time = oldest_request + self.window_seconds - current_time        return max(0, reset_time)    async def _cleanup_expired_entries(self, current_time: float):        """–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Automatic cleanup –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è memory leaks."""        cutoff_time = current_time - (self.window_seconds * 2)  # Double window –¥–ª—è safety        expired_ips = []        for ip, data in self._requests.items():            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ timestamps            data["timestamps"] = [                ts for ts in data["timestamps"]                if ts > cutoff_time            ]            # –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö timestamps, –ø–æ–º–µ—á–∞–µ–º IP –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è            if not data["timestamps"] and data["created_at"] < cutoff_time:                expired_ips.append(ip)        # –£–¥–∞–ª—è–µ–º expired IPs        for ip in expired_ips:            del self._requests[ip]        if expired_ips:            logger.debug(f"Cleaned up {len(expired_ips)} expired rate limit entries")def get_cors_origins() -> List[str]:    """    –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è CORS origins.    –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:    ‚úÖ No duplicates    ‚úÖ Better environment handling    ‚úÖ Validation of origins    """    cors_origins = set()  # Use set to avoid duplicates    # –í development - –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ development origins    if settings.is_development() or settings.debug:        development_origins = {            "http://localhost:3000",    # React/Next.js dev server            "http://localhost:3001",            "http://127.0.0.1:3000",            "http://127.0.0.1:3001",            "http://localhost:8080",    # Vue dev server            "http://localhost:8081",            "http://localhost:4200",    # Angular dev server            "http://localhost:5173",    # Vite dev server            "http://localhost:5174",            "http://localhost:8000",    # FastAPI dev server            "http://localhost:8001",        }        cors_origins.update(development_origins)    # –î–æ–±–∞–≤–ª—è–µ–º origins –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫    if hasattr(settings, 'cors_origins_list') and settings.cors_origins_list:        cors_origins.update(settings.cors_origins_list)    # Frontend URL –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫    if hasattr(settings, 'frontend_url') and settings.frontend_url:        cors_origins.add(settings.frontend_url)    # Base URL –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫    if hasattr(settings, 'base_url') and settings.base_url:        cors_origins.add(settings.base_url)    # –í production –¥–æ–±–∞–≤–ª—è–µ–º production –¥–æ–º–µ–Ω—ã    if settings.is_production():        production_origins = {            "https://yourdomain.com",            "https://www.yourdomain.com",            "https://api.yourdomain.com"        }        cors_origins.update(production_origins)    # –§–∏–ª—å—Ç—Ä—É–µ–º –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º origins    valid_origins = []    for origin in cors_origins:        if origin and isinstance(origin, str) and origin.strip():            cleaned_origin = origin.strip().rstrip('/')            if cleaned_origin.startswith(('http://', 'https://')):                valid_origins.append(cleaned_origin)    return valid_originsdef setup_middleware(app: FastAPI) -> None:    """    –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –≤—Å–µ—Ö middleware.    –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:    ‚úÖ Proper order –¥–ª—è middleware    ‚úÖ Enhanced error handling    ‚úÖ Better configuration    """    logger.info("üîß Setting up security-focused middleware...")    # –ü–æ–ª—É—á–∞–µ–º –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º CORS origins    cors_origins = get_cors_origins()    logger.info(f"üåê CORS Origins ({len(cors_origins)}): {', '.join(cors_origins[:5])}{'...' if len(cors_origins) > 5 else ''}")    # 1. CORS (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–µ—Ä–≤—ã–º –¥–ª—è preflight requests)    app.add_middleware(        CORSMiddleware,        allow_origins=cors_origins,        allow_credentials=True,        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"],        allow_headers=[            "Accept",            "Accept-Language",            "Content-Language",            "Content-Type",            "Authorization",            "X-Requested-With",            "X-Request-ID",            "X-Session-ID",            "User-Agent",            "Referer",            "Origin",            "Access-Control-Request-Method",            "Access-Control-Request-Headers",            "Cache-Control",            "Pragma"        ],        expose_headers=[            "X-Request-ID",            "X-Process-Time",            "X-RateLimit-Limit",            "X-RateLimit-Remaining",            "X-RateLimit-Reset",            "Content-Disposition",            "Content-Type",            "Content-Length"        ]    )    logger.info("‚úÖ Secure CORS middleware configured")    # 2. Request Validation (—Ä–∞–Ω–Ω–µ–µ –≤—ã—è–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º)    @app.middleware("http")    async def request_validation_middleware(request: Request, call_next):        """Basic request validation."""        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä Content-Length        content_length = request.headers.get("content-length")        if content_length and int(content_length) > 10_000_000:  # 10MB limit            return JSONResponse(                status_code=413,                content={"error": True, "message": "Request entity too large"}            )        return await call_next(request)    logger.info("‚úÖ Request Validation middleware configured")    # 3. Security Headers    app.add_middleware(SecurityHeadersMiddleware)    logger.info("‚úÖ Enhanced Security Headers middleware configured")    # 4. Rate Limiting (–≤ production –∏–ª–∏ –µ—Å–ª–∏ —è–≤–Ω–æ –≤–∫–ª—é—á–µ–Ω–æ)    if settings.is_production() or getattr(settings, 'enable_rate_limiting', False):        app.add_middleware(EnhancedRateLimitMiddleware)        logger.info("‚úÖ Enhanced Rate Limiting middleware configured")    else:        logger.info("‚ö†Ô∏è Rate Limiting disabled in debug mode")    # 5. GZip —Å–∂–∞—Ç–∏–µ    app.add_middleware(GZipMiddleware, minimum_size=500)    logger.info("‚úÖ GZip compression middleware configured")    # 6. Sessions (–¥–ª—è –≥–æ—Å—Ç–µ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)    app.add_middleware(        SessionMiddleware,        secret_key=settings.secret_key,        max_age=settings.guest_session_expire_hours * 3600,        same_site="lax",        https_only=settings.is_production(),        session_cookie="gemup_session"    )    logger.info("‚úÖ Session middleware configured")    # 7. Request Logging (–ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞)    app.add_middleware(EnhancedRequestLoggingMiddleware)    logger.info("‚úÖ Enhanced Request Logging middleware configured")    logger.info("üöÄ All middleware configured successfully with security focus")def setup_error_handlers(app: FastAPI) -> None:    """    –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –æ—à–∏–±–æ–∫.    Args:        app: –≠–∫–∑–µ–º–ø–ª—è—Ä FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è    """    from app.core.exceptions import setup_exception_handlers    setup_exception_handlers(app)    logger.info("‚úÖ Error handlers configured")