"""CRUD операции для заказов.Содержит методы для создания, обновления и управления заказами пользователей."""import loggingfrom datetime import datetime, timedeltafrom typing import List, Optionalfrom decimal import Decimalfrom sqlalchemy import select, func, and_, or_from sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.orm import selectinloadfrom app.crud.base import CRUDBasefrom app.models.models import Order, OrderStatus, OrderItemfrom app.schemas.order import OrderCreate, OrderUpdatelogger = logging.getLogger(__name__)class CRUDOrder(CRUDBase[Order, OrderCreate, OrderUpdate]):    """    CRUD для управления заказами.    Обеспечивает создание, обновление и поиск заказов с полной загрузкой    связанных данных (элементы заказа, продукты).    """    @staticmethod    async def get_with_items(db: AsyncSession, *, order_id: int) -> Optional[Order]:        """        Получение заказа с элементами.        Args:            db: Сессия базы данных            order_id: ID заказа        Returns:            Optional[Order]: Заказ с загруженными элементами или None        """        try:            result = await db.execute(                select(Order)                .options(selectinload(Order.order_items))                .where(Order.id == order_id)            )            return result.scalar_one_or_none()        except Exception as e:            logger.error(f"Error getting order {order_id} with items: {e}")            raise    @staticmethod    async def get_user_orders(            db: AsyncSession,            *,            user_id: int,            status: Optional[OrderStatus] = None,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Получение заказов пользователя.        Args:            db: Сессия базы данных            user_id: ID пользователя            status: Фильтр по статусу заказа            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список заказов пользователя        """        try:            query = (                select(Order)                .options(selectinload(Order.order_items))                .where(Order.user_id == user_id)            )            if status:                query = query.where(Order.status == status)            query = query.order_by(Order.created_at.desc()).offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting orders for user {user_id}: {e}")            return []    @staticmethod    async def get_by_order_number(            db: AsyncSession,            *,            order_number: str    ) -> Optional[Order]:        """        Получение заказа по номеру.        Args:            db: Сессия базы данных            order_number: Номер заказа        Returns:            Optional[Order]: Заказ или None        """        try:            result = await db.execute(                select(Order)                .options(selectinload(Order.order_items))                .where(Order.order_number == order_number)            )            return result.scalar_one_or_none()        except Exception as e:            logger.error(f"Error getting order by number {order_number}: {e}")            raise    @staticmethod    async def get_orders_by_status(            db: AsyncSession,            *,            status: OrderStatus,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Получение заказов по статусу.        Args:            db: Сессия базы данных            status: Статус заказа            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список заказов с указанным статусом        """        try:            result = await db.execute(                select(Order)                .where(Order.status == status)                .order_by(Order.created_at.desc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting orders by status {status}: {e}")            return []    @staticmethod    async def update_status(            db: AsyncSession,            *,            order: Order,            status: OrderStatus,            payment_id: Optional[str] = None    ) -> Order:        """        Обновление статуса заказа.        Args:            db: Сессия базы данных            order: Заказ для обновления            status: Новый статус            payment_id: ID платежа (опционально)        Returns:            Order: Обновленный заказ        """        try:            order.status = status            if payment_id:                order.payment_id = payment_id            order.updated_at = datetime.now()            await db.commit()            await db.refresh(order)            logger.info(f"Updated order {order.id} status to {status}")            return order        except Exception as e:            await db.rollback()            logger.error(f"Error updating order {order.id} status: {e}")            raise    @staticmethod    async def get_expired_orders(            db: AsyncSession,            *,            hours_old: int = 24    ) -> List[Order]:        """        Получение просроченных заказов.        Args:            db: Сессия базы данных            hours_old: Количество часов для определения просрочки        Returns:            List[Order]: Список просроченных заказов        """        try:            expiry_time = datetime.now() - timedelta(hours=hours_old)            result = await db.execute(                select(Order).where(                    and_(                        Order.status == OrderStatus.PENDING,                        Order.created_at < expiry_time                    )                )            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting expired orders: {e}")            return []    @staticmethod    async def calculate_total_amount(            *,            order_items: List[OrderItem]    ) -> Decimal:        """        Расчет общей суммы заказа.        Args:            order_items: Элементы заказа        Returns:            Decimal: Общая сумма заказа        """        try:            total = Decimal('0.00')            for item in order_items:                total += item.total_price            return total        except Exception as e:            logger.error(f"Error calculating order total: {e}")            return Decimal('0.00')    @staticmethod    async def get_order_stats(            db: AsyncSession,            *,            user_id: Optional[int] = None,            days: int = 30    ) -> dict:        """        Получение статистики заказов.        Args:            db: Сессия базы данных            user_id: ID пользователя (опционально, для статистики конкретного пользователя)            days: Период для статистики в днях        Returns:            dict: Статистика заказов        """        try:            start_date = datetime.now() - timedelta(days=days)            query = select(Order).where(Order.created_at >= start_date)            if user_id:                query = query.where(Order.user_id == user_id)            # Общее количество заказов            total_orders_result = await db.execute(                select(func.count(Order.id)).select_from(query.subquery())            )            total_orders = total_orders_result.scalar() or 0            # Общая сумма            total_amount_result = await db.execute(                select(func.sum(Order.total_amount)).select_from(query.subquery())            )            total_amount = total_amount_result.scalar() or Decimal('0.00')            # Статистика по статусам            status_stats = {}            for status in OrderStatus:                status_result = await db.execute(                    select(func.count(Order.id))                    .select_from(query.where(Order.status == status).subquery())                )                status_stats[status.value] = status_result.scalar() or 0            return {                "total_orders": total_orders,                "total_amount": str(total_amount),                "status_breakdown": status_stats,                "period_days": days            }        except Exception as e:            logger.error(f"Error getting order stats: {e}")            return {                "total_orders": 0,                "total_amount": "0.00",                "status_breakdown": {},                "period_days": days            }    @staticmethod    async def search_orders(            db: AsyncSession,            *,            search_term: str,            user_id: Optional[int] = None,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Поиск заказов по номеру или описанию.        Args:            db: Сессия базы данных            search_term: Поисковый термин            user_id: ID пользователя (опционально)            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список найденных заказов        """        try:            search_pattern = f"%{search_term}%"            query = select(Order).where(                or_(                    Order.order_number.ilike(search_pattern),                    Order.notes.ilike(search_pattern)                )            )            if user_id:                query = query.where(Order.user_id == user_id)            query = query.order_by(Order.created_at.desc()).offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error searching orders with term '{search_term}': {e}")            return []order_crud = CRUDOrder(Order)