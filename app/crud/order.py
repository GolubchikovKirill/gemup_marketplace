from typing import Optional, Listfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy import select, and_from sqlalchemy.orm import selectinloadfrom datetime import datetime, timedeltaimport uuidfrom app.crud.base import CRUDBasefrom app.models.models import Order, OrderItem, OrderStatusfrom app.schemas.order import OrderCreate, OrderUpdateclass CRUDOrder(CRUDBase[Order, OrderCreate, OrderUpdate]):    async def get(self, db: AsyncSession, obj_id: int) -> Optional[Order]:        """Получение заказа с загрузкой связанных данных"""        result = await db.execute(            select(Order)            .options(                selectinload(Order.order_items).selectinload(OrderItem.proxy_product),                selectinload(Order.user)            )            .where(Order.id == obj_id)        )        return result.scalar_one_or_none()    @staticmethod    async def create_order_from_cart(            db: AsyncSession,            *,            user_id: int,            cart_items: List,            payment_method: Optional[str] = None    ) -> Order:        """Создать заказ из корзины"""        order_number = f"ORD-{datetime.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}"        # Рассчитываем общую сумму        total_amount = 0.0        for item in cart_items:            if item.proxy_product and item.proxy_product.is_active:                total_amount += float(item.proxy_product.price_per_proxy) * item.quantity        # Создаем заказ        order = Order(            order_number=order_number,            user_id=user_id,            total_amount=total_amount,            payment_method=payment_method,            status=OrderStatus.PENDING,            expires_at=datetime.now() + timedelta(hours=1)        )        db.add(order)        await db.commit()        await db.refresh(order)        # Создаем элементы заказа        for cart_item in cart_items:            if cart_item.proxy_product and cart_item.proxy_product.is_active:                unit_price = cart_item.proxy_product.price_per_proxy                total_price = float(unit_price) * cart_item.quantity                order_item = OrderItem(                    order_id=order.id,                    proxy_product_id=cart_item.proxy_product_id,                    quantity=cart_item.quantity,                    unit_price=unit_price,                    total_price=total_price,                    generation_params=cart_item.generation_params                )                db.add(order_item)        await db.commit()        # Загружаем заказ с связанными данными        result = await db.execute(            select(Order)            .options(                selectinload(Order.order_items).selectinload(OrderItem.proxy_product),                selectinload(Order.user)            )            .where(Order.id == order.id)        )        return result.scalar_one()    @staticmethod    async def get_user_orders(            db: AsyncSession,            *,            user_id: int,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """Получить заказы пользователя с загрузкой связанных данных"""        result = await db.execute(            select(Order)            .options(                selectinload(Order.order_items).selectinload(OrderItem.proxy_product),                selectinload(Order.user)            )            .where(Order.user_id == user_id)            .order_by(Order.created_at.desc())            .offset(skip).limit(limit)        )        return list(result.scalars().all())    @staticmethod    async def get_by_order_number(db: AsyncSession, *, order_number: str) -> Optional[Order]:        """Получить заказ по номеру с загрузкой связанных данных"""        result = await db.execute(            select(Order)            .options(                selectinload(Order.order_items).selectinload(OrderItem.proxy_product),                selectinload(Order.user)            )            .where(Order.order_number == order_number)        )        return result.scalar_one_or_none()    async def update_status(            self,            db: AsyncSession,            *,            order_id: int,            status: OrderStatus    ) -> Optional[Order]:        """Обновить статус заказа"""        order = await self.get(db, obj_id=order_id)        if order:            order.status = status            order.updated_at = datetime.now()            await db.commit()            await db.refresh(order)        return order    @staticmethod    async def get_pending_orders(db: AsyncSession) -> List[Order]:        """Получить заказы в ожидании оплаты"""        result = await db.execute(            select(Order)            .options(selectinload(Order.order_items))            .where(Order.status == OrderStatus.PENDING)        )        return list(result.scalars().all())    @staticmethod    async def get_expired_orders(db: AsyncSession) -> List[Order]:        """Получить просроченные заказы"""        result = await db.execute(            select(Order)            .options(selectinload(Order.order_items))            .where(                and_(                    Order.status == OrderStatus.PENDING,                    Order.expires_at < datetime.now()                )            )        )        return list(result.scalars().all())    async def cancel_expired_orders(self, db: AsyncSession) -> int:        """Отменить просроченные заказы"""        expired_orders = await self.get_expired_orders(db)        count = len(expired_orders)        for order in expired_orders:            order.status = OrderStatus.CANCELLED            order.updated_at = datetime.now()        await db.commit()        return countorder_crud = CRUDOrder(Order)