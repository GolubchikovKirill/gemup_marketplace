"""CRUD операции для заказов.Содержит методы для создания, обновления и управления заказами пользователей,включая элементы заказов, расчеты и статистику."""import loggingimport uuidfrom datetime import datetime, timedelta, timezonefrom decimal import Decimalfrom typing import List, Optional, Dict, Anyfrom sqlalchemy import select, func, and_, or_, desc, updatefrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.orm import selectinloadfrom app.crud.base import CRUDBasefrom app.models.models import Order, OrderStatus, OrderItem, ProxyProductfrom app.schemas.order import (    OrderCreate, OrderUpdate, OrderCreateFromCart, OrderFilter,    OrderItemCreate, OrderCalculationRequest)logger = logging.getLogger(__name__)class CRUDOrder(CRUDBase[Order, OrderCreate, OrderUpdate]):    """    CRUD для управления заказами.    Обеспечивает создание, обновление и поиск заказов с полной загрузкой    связанных данных (элементы заказа, продукты, пользователи).    """    async def create_order_with_items(            self,            db: AsyncSession,            *,            user_id: int,            order_in: OrderCreate    ) -> Optional[Order]:        """        Создание заказа с элементами.        Args:            db: Сессия базы данных            user_id: ID пользователя            order_in: Данные для создания заказа        Returns:            Optional[Order]: Созданный заказ или None        """        try:            # Генерируем уникальный номер заказа            order_number = await self._generate_order_number(db)            # Рассчитываем общую сумму заказа            total_amount = await self._calculate_order_total(db, order_in.items)            if total_amount <= 0:                raise ValueError("Order total amount must be positive")            # Создаем заказ            db_order = Order(                order_number=order_number,                user_id=user_id,                total_amount=total_amount,                currency=order_in.currency,                status=OrderStatus.PENDING,                payment_method=order_in.payment_method,                expires_at=order_in.expires_at,                created_at=datetime.now(timezone.utc),                updated_at=datetime.now(timezone.utc)            )            db.add(db_order)            await db.flush()  # Получаем ID заказа            # Создаем элементы заказа            for item_data in order_in.items:                # Получаем продукт для расчета цены                product = await db.get(ProxyProduct, item_data.proxy_product_id)                if not product or not product.is_active:                    raise ValueError(f"Product {item_data.proxy_product_id} not found or inactive")                unit_price = product.price_per_proxy                total_price = unit_price * item_data.quantity                order_item = OrderItem(                    order_id=db_order.id,                    proxy_product_id=item_data.proxy_product_id,                    quantity=item_data.quantity,                    unit_price=unit_price,                    total_price=total_price,                    generation_params=item_data.generation_params,                    created_at=datetime.now(timezone.utc)                )                db.add(order_item)            await db.commit()            await db.refresh(db_order)            logger.info(f"Created order {db_order.order_number} for user {user_id}")            return db_order        except ValueError:            await db.rollback()            raise        except Exception as e:            await db.rollback()            logger.error(f"Error creating order for user {user_id}: {e}")            return None    async def create_order_from_cart(            self,            db: AsyncSession,            *,            user_id: int,            order_in: OrderCreateFromCart,            cart_items: List[Any]  # ShoppingCart items    ) -> Optional[Order]:        """        Создание заказа из корзины.        Args:            db: Сессия базы данных            user_id: ID пользователя            order_in: Данные для создания заказа            cart_items: Элементы корзины        Returns:            Optional[Order]: Созданный заказ или None        """        try:            if not cart_items:                raise ValueError("Cart is empty")            # Конвертируем элементы корзины в элементы заказа            order_items = []            for cart_item in cart_items:                if order_in.cart_item_ids is None or cart_item.id in order_in.cart_item_ids:                    order_items.append(OrderItemCreate(                        proxy_product_id=cart_item.proxy_product_id,                        quantity=cart_item.quantity,                        generation_params=cart_item.generation_params                    ))            if not order_items:                raise ValueError("No valid cart items found")            # Создаем заказ            order_create = OrderCreate(                items=order_items,                currency=order_in.currency,                payment_method=order_in.payment_method,                expires_at=order_in.expires_at            )            return await self.create_order_with_items(db, user_id=user_id, order_in=order_create)        except ValueError:            raise        except Exception as e:            logger.error(f"Error creating order from cart for user {user_id}: {e}")            return None    async def get_with_items(self, db: AsyncSession, *, order_id: int) -> Optional[Order]:        """        Получение заказа с элементами.        Args:            db: Сессия базы данных            order_id: ID заказа        Returns:            Optional[Order]: Заказ с загруженными элементами или None        """        try:            result = await db.execute(                select(Order)                .options(                    selectinload(Order.order_items).selectinload(OrderItem.proxy_product),                    selectinload(Order.user),                    selectinload(Order.transactions),                    selectinload(Order.proxy_purchases)                )                .where(Order.id == order_id)            )            return result.scalar_one_or_none()        except Exception as e:            logger.error(f"Error getting order {order_id} with items: {e}")            return None    async def get_by_order_number(            self,            db: AsyncSession,            *,            order_number: str    ) -> Optional[Order]:        """        Получение заказа по номеру.        Args:            db: Сессия базы данных            order_number: Номер заказа        Returns:            Optional[Order]: Заказ или None        """        try:            result = await db.execute(                select(Order)                .options(                    selectinload(Order.order_items).selectinload(OrderItem.proxy_product)                )                .where(Order.order_number == order_number)            )            return result.scalar_one_or_none()        except Exception as e:            logger.error(f"Error getting order by number {order_number}: {e}")            return None    async def get_user_orders(            self,            db: AsyncSession,            *,            user_id: int,            status: Optional[OrderStatus] = None,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Получение заказов пользователя.        Args:            db: Сессия базы данных            user_id: ID пользователя            status: Фильтр по статусу заказа            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список заказов пользователя        """        try:            query = (                select(Order)                .options(selectinload(Order.order_items))                .where(Order.user_id == user_id)            )            if status:                query = query.where(Order.status == status)            query = query.order_by(desc(Order.created_at)).offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting orders for user {user_id}: {e}")            return []    async def get_orders_by_status(            self,            db: AsyncSession,            *,            status: OrderStatus,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Получение заказов по статусу.        Args:            db: Сессия базы данных            status: Статус заказа            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список заказов с указанным статусом        """        try:            result = await db.execute(                select(Order)                .where(Order.status == status)                .order_by(desc(Order.created_at))                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting orders by status {status}: {e}")            return []    async def get_orders_with_filter(            self,            db: AsyncSession,            *,            filter_params: OrderFilter,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Получение заказов с фильтрацией.        Args:            db: Сессия базы данных            filter_params: Параметры фильтрации            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список отфильтрованных заказов        """        try:            query = select(Order).options(selectinload(Order.order_items))            # Применяем фильтры            if filter_params.user_id:                query = query.where(Order.user_id == filter_params.user_id)            if filter_params.status:                query = query.where(Order.status == filter_params.status)            if filter_params.payment_method:                query = query.where(Order.payment_method == filter_params.payment_method)            if filter_params.min_amount:                query = query.where(Order.total_amount >= filter_params.min_amount)            if filter_params.max_amount:                query = query.where(Order.total_amount <= filter_params.max_amount)            if filter_params.created_after:                query = query.where(Order.created_at >= filter_params.created_after)            if filter_params.created_before:                query = query.where(Order.created_at <= filter_params.created_before)            if filter_params.expires_after:                query = query.where(Order.expires_at >= filter_params.expires_after)            if filter_params.expires_before:                query = query.where(Order.expires_at <= filter_params.expires_before)            if filter_params.order_number:                query = query.where(Order.order_number.ilike(f"%{filter_params.order_number}%"))            query = query.order_by(desc(Order.created_at)).offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting orders with filter: {e}")            return []    async def update_status(            self,            db: AsyncSession,            *,            order: Order,            status: OrderStatus,            reason: Optional[str] = None    ) -> Order:        """        Обновление статуса заказа.        Args:            db: Сессия базы данных            order: Заказ для обновления            status: Новый статус            reason: Причина изменения статуса        Returns:            Order: Обновленный заказ        """        try:            old_status = order.status            order.status = status            order.updated_at = datetime.now(timezone.utc)            await db.commit()            await db.refresh(order)            logger.info(f"Updated order {order.id} status from {old_status} to {status}. Reason: {reason}")            return order        except Exception as e:            await db.rollback()            logger.error(f"Error updating order {order.id} status: {e}")            raise    async def cancel_order(            self,            db: AsyncSession,            *,            order: Order,            reason: str,            refund_amount: Optional[Decimal] = None    ) -> Order:        """        Отмена заказа.        Args:            db: Сессия базы данных            order: Заказ для отмены            reason: Причина отмены            refund_amount: Сумма возврата        Returns:            Order: Отмененный заказ        """        try:            if order.status in [OrderStatus.COMPLETED, OrderStatus.CANCELLED]:                raise ValueError(f"Cannot cancel order with status {order.status}")            order.status = OrderStatus.CANCELLED            order.updated_at = datetime.now(timezone.utc)            await db.commit()            await db.refresh(order)            logger.info(f"Cancelled order {order.id}. Reason: {reason}")            return order        except ValueError:            raise        except Exception as e:            await db.rollback()            logger.error(f"Error cancelling order {order.id}: {e}")            raise    async def get_expired_orders(            self,            db: AsyncSession,            *,            hours_old: int = 24    ) -> List[Order]:        """        Получение просроченных заказов.        Args:            db: Сессия базы данных            hours_old: Количество часов для определения просрочки        Returns:            List[Order]: Список просроченных заказов        """        try:            current_time = datetime.now(timezone.utc)            result = await db.execute(                select(Order).where(                    and_(                        Order.status == OrderStatus.PENDING,                        or_(                            Order.expires_at < current_time,                            and_(                                Order.expires_at.is_(None),                                Order.created_at < current_time - timedelta(hours=hours_old)                            )                        )                    )                )            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting expired orders: {e}")            return []    async def calculate_order_total(            self,            db: AsyncSession,            *,            calculation_request: OrderCalculationRequest    ) -> Dict[str, Any]:        """        Расчет стоимости заказа.        Args:            db: Сессия базы данных            calculation_request: Запрос расчета        Returns:            Dict[str, Any]: Детали расчета        """        try:            items_details = []            subtotal = Decimal('0.00')            for item in calculation_request.items:                # Получаем продукт                product = await db.get(ProxyProduct, item.proxy_product_id)                if not product or not product.is_active:                    raise ValueError(f"Product {item.proxy_product_id} not found or inactive")                unit_price = product.price_per_proxy                total_price = unit_price * item.quantity                subtotal += total_price                items_details.append({                    "proxy_product_id": item.proxy_product_id,                    "product_name": product.name,                    "quantity": item.quantity,                    "unit_price": str(unit_price),                    "total_price": str(total_price)                })            # Применяем промокод (если есть)            discount = Decimal('0.00')            promo_code_applied = None            if calculation_request.promo_code:                # Здесь должна быть логика применения промокода                # discount = await self._apply_promo_code(db, calculation_request.promo_code, subtotal)                # promo_code_applied = calculation_request.promo_code                pass            total = subtotal - discount            return {                "items": items_details,                "subtotal": str(subtotal),                "discount": str(discount),                "total": str(total),                "currency": "USD",                "promo_code_applied": promo_code_applied            }        except ValueError:            raise        except Exception as e:            logger.error(f"Error calculating order total: {e}")            raise    async def get_order_stats(            self,            db: AsyncSession,            *,            user_id: Optional[int] = None,            days: int = 30    ) -> Dict[str, Any]:        """        Получение статистики заказов.        Args:            db: Сессия базы данных            user_id: ID пользователя (опционально)            days: Период для статистики в днях        Returns:            Dict[str, Any]: Статистика заказов        """        try:            start_date = datetime.now(timezone.utc) - timedelta(days=days)            base_query = select(Order).where(Order.created_at >= start_date)            if user_id:                base_query = base_query.where(Order.user_id == user_id)            # Общее количество заказов            total_result = await db.execute(                select(func.count(Order.id)).select_from(base_query.subquery())            )            total_orders = total_result.scalar() or 0            # Общая выручка            revenue_result = await db.execute(                select(func.sum(Order.total_amount)).select_from(                    base_query.where(Order.status.in_([OrderStatus.PAID, OrderStatus.COMPLETED])).subquery()                )            )            total_revenue = revenue_result.scalar() or Decimal('0.00')            # Статистика по статусам            status_stats = {}            for status in OrderStatus:                status_result = await db.execute(                    select(func.count(Order.id)).select_from(                        base_query.where(Order.status == status).subquery()                    )                )                status_stats[f"{status.value}_orders"] = status_result.scalar() or 0            # Средняя стоимость заказа            avg_order_value = total_revenue / max(total_orders, 1)            return {                "total_orders": total_orders,                "total_revenue": str(total_revenue),                "average_order_value": str(avg_order_value),                "period_days": days,                **status_stats            }        except Exception as e:            logger.error(f"Error getting order stats: {e}")            return {                "total_orders": 0,                "total_revenue": "0.00000000",                "average_order_value": "0.00000000",                "period_days": days            }    async def search_orders(            self,            db: AsyncSession,            *,            search_term: str,            user_id: Optional[int] = None,            skip: int = 0,            limit: int = 100    ) -> List[Order]:        """        Поиск заказов по номеру.        Args:            db: Сессия базы данных            search_term: Поисковый термин            user_id: ID пользователя (опционально)            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[Order]: Список найденных заказов        """        try:            if not search_term or len(search_term.strip()) < 2:                return []            search_pattern = f"%{search_term.strip()}%"            query = select(Order).where(Order.order_number.ilike(search_pattern))            if user_id:                query = query.where(Order.user_id == user_id)            query = query.order_by(desc(Order.created_at)).offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error searching orders with term '{search_term}': {e}")            return []    async def bulk_update_status(            self,            db: AsyncSession,            *,            order_ids: List[int],            status: OrderStatus,            reason: Optional[str] = None    ) -> int:        """        Массовое обновление статуса заказов.        Args:            db: Сессия базы данных            order_ids: Список ID заказов            status: Новый статус            reason: Причина изменения        Returns:            int: Количество обновленных заказов        """        try:            if not order_ids:                return 0            result = await db.execute(                update(Order)                .where(Order.id.in_(order_ids))                .values(                    status=status,                    updated_at=datetime.now(timezone.utc)                )            )            await db.commit()            updated_count = result.rowcount or 0            logger.info(f"Bulk updated {updated_count} orders to status {status}. Reason: {reason}")            return updated_count        except Exception as e:            await db.rollback()            logger.error(f"Error bulk updating orders: {e}")            return 0    async def cleanup_expired_orders(self, db: AsyncSession) -> int:        """        Очистка просроченных заказов.        Args:            db: Сессия базы данных        Returns:            int: Количество отмененных заказов        """        try:            expired_orders = await self.get_expired_orders(db, hours_old=24)            if not expired_orders:                return 0            order_ids = [order.id for order in expired_orders]            return await self.bulk_update_status(                db,                order_ids=order_ids,                status=OrderStatus.CANCELLED,                reason="Automatic cancellation due to expiration"            )        except Exception as e:            logger.error(f"Error cleaning up expired orders: {e}")            return 0    # Приватные методы    async def _generate_order_number(self, db: AsyncSession) -> str:        """Генерация уникального номера заказа."""        while True:            # Формат: ORD-YYYYMMDD-XXXXX            date_part = datetime.now().strftime("%Y%m%d")            random_part = str(uuid.uuid4())[:8].upper()            order_number = f"ORD-{date_part}-{random_part}"            # Проверяем уникальность            existing = await self.get_by_order_number(db, order_number=order_number)            if not existing:                return order_number    async def _calculate_order_total(self, db: AsyncSession, items: List[OrderItemCreate]) -> Decimal:        """Расчет общей суммы заказа."""        total = Decimal('0.00')        for item in items:            product = await db.get(ProxyProduct, item.proxy_product_id)            if not product or not product.is_active:                raise ValueError(f"Product {item.proxy_product_id} not found or inactive")            item_total = product.price_per_proxy * item.quantity            total += item_total        return totalorder_crud = CRUDOrder(Order)