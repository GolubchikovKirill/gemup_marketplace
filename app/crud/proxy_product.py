import loggingfrom decimal import Decimalfrom typing import Listfrom sqlalchemy import select, func, or_, distinctfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.crud.base import CRUDBasefrom app.models.models import ProxyProduct, ProxyCategoryfrom app.schemas.proxy_product import ProxyProductCreate, ProxyProductUpdate, ProductFilterlogger = logging.getLogger(__name__)class CRUDProxyProduct(CRUDBase[ProxyProduct, ProxyProductCreate, ProxyProductUpdate]):    async def get_products_with_filter(            self,            db: AsyncSession,            *,            filter_params: ProductFilter,            skip: int = 0,            limit: int = 20    ) -> List[ProxyProduct]:        """Получение продуктов с фильтрацией"""        try:            query = select(ProxyProduct).where(ProxyProduct.is_active.is_(True))            # Применяем фильтры            if filter_params.search:                search_term = f"%{filter_params.search}%"                query = query.where(                    or_(                        ProxyProduct.name.ilike(search_term),                        ProxyProduct.description.ilike(search_term)                    )                )            if filter_params.proxy_category:                query = query.where(ProxyProduct.proxy_category == filter_params.proxy_category)            if filter_params.proxy_type:                query = query.where(ProxyProduct.proxy_type == filter_params.proxy_type)            if filter_params.provider:                query = query.where(ProxyProduct.provider == filter_params.provider)            if filter_params.country:                query = query.where(ProxyProduct.country_code == filter_params.country)            if filter_params.min_price is not None:                query = query.where(ProxyProduct.price_per_proxy >= Decimal(str(filter_params.min_price)))            if filter_params.max_price is not None:                query = query.where(ProxyProduct.price_per_proxy <= Decimal(str(filter_params.max_price)))            if filter_params.min_points_per_hour is not None:                query = query.where(ProxyProduct.points_per_hour >= filter_params.min_points_per_hour)            if filter_params.auto_claim_only:                query = query.where(ProxyProduct.auto_claim.is_(True))            # ДОБАВЛЕНО: Новые фильтры            if filter_params.min_farm_efficiency is not None:                query = query.where(ProxyProduct.farm_efficiency >= Decimal(str(filter_params.min_farm_efficiency)))            if filter_params.multi_account_only:                query = query.where(ProxyProduct.multi_account_support.is_(True))            if filter_params.min_speed is not None:                query = query.where(ProxyProduct.speed_mbps >= filter_params.min_speed)            if filter_params.min_uptime is not None:                query = query.where(ProxyProduct.uptime_guarantee >= Decimal(str(filter_params.min_uptime)))            # Сортировка            if filter_params.sort == "price_asc":                query = query.order_by(ProxyProduct.price_per_proxy.asc())            elif filter_params.sort == "price_desc":                query = query.order_by(ProxyProduct.price_per_proxy.desc())            elif filter_params.sort == "name_asc":                query = query.order_by(ProxyProduct.name.asc())            elif filter_params.sort == "name_desc":                query = query.order_by(ProxyProduct.name.desc())            elif filter_params.sort == "points_desc":                query = query.order_by(ProxyProduct.points_per_hour.desc())            elif filter_params.sort == "efficiency_desc":                query = query.order_by(ProxyProduct.farm_efficiency.desc())            elif filter_params.sort == "speed_desc":                query = query.order_by(ProxyProduct.speed_mbps.desc())            elif filter_params.sort == "uptime_desc":                query = query.order_by(ProxyProduct.uptime_guarantee.desc())            else:  # created_at_desc по умолчанию                query = query.order_by(ProxyProduct.created_at.desc())            # Пагинация            query = query.offset(skip).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error in get_products_with_filter: {e}")            return []    async def count_products_with_filter(            self,            db: AsyncSession,            *,            filter_params: ProductFilter    ) -> int:        """Подсчет продуктов с фильтрацией"""        try:            query = select(func.count(ProxyProduct.id)).where(ProxyProduct.is_active.is_(True))            # Применяем те же фильтры            if filter_params.search:                search_term = f"%{filter_params.search}%"                query = query.where(                    or_(                        ProxyProduct.name.ilike(search_term),                        ProxyProduct.description.ilike(search_term)                    )                )            if filter_params.proxy_category:                query = query.where(ProxyProduct.proxy_category == filter_params.proxy_category)            if filter_params.proxy_type:                query = query.where(ProxyProduct.proxy_type == filter_params.proxy_type)            if filter_params.provider:                query = query.where(ProxyProduct.provider == filter_params.provider)            if filter_params.country:                query = query.where(ProxyProduct.country_code == filter_params.country)            if filter_params.min_price is not None:                query = query.where(ProxyProduct.price_per_proxy >= Decimal(str(filter_params.min_price)))            if filter_params.max_price is not None:                query = query.where(ProxyProduct.price_per_proxy <= Decimal(str(filter_params.max_price)))            if filter_params.min_points_per_hour is not None:                query = query.where(ProxyProduct.points_per_hour >= filter_params.min_points_per_hour)            if filter_params.auto_claim_only:                query = query.where(ProxyProduct.auto_claim.is_(True))            # ДОБАВЛЕНО: Новые фильтры            if filter_params.min_farm_efficiency is not None:                query = query.where(ProxyProduct.farm_efficiency >= Decimal(str(filter_params.min_farm_efficiency)))            if filter_params.multi_account_only:                query = query.where(ProxyProduct.multi_account_support.is_(True))            if filter_params.min_speed is not None:                query = query.where(ProxyProduct.speed_mbps >= filter_params.min_speed)            if filter_params.min_uptime is not None:                query = query.where(ProxyProduct.uptime_guarantee >= Decimal(str(filter_params.min_uptime)))            result = await db.execute(query)            return result.scalar() or 0        except Exception as e:            logger.error(f"Error in count_products_with_filter: {e}")            return 0    async def get_products_by_category(            self,            db: AsyncSession,            *,            category: ProxyCategory,            skip: int = 0,            limit: int = 20    ) -> List[ProxyProduct]:        """Получение продуктов по категории"""        try:            result = await db.execute(                select(ProxyProduct)                .where(ProxyProduct.proxy_category == category)                .where(ProxyProduct.is_active.is_(True))                .offset(skip)                .limit(limit)                .order_by(ProxyProduct.created_at.desc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by category: {e}")            return []    async def count_products_by_category(            self,            db: AsyncSession,            category: ProxyCategory    ) -> int:        """Подсчет продуктов в категории"""        try:            result = await db.execute(                select(func.count(ProxyProduct.id))                .where(ProxyProduct.proxy_category == category)                .where(ProxyProduct.is_active.is_(True))            )            return result.scalar() or 0        except Exception as e:            logger.error(f"Error counting products by category: {e}")            return 0    async def get_available_countries(self, db: AsyncSession) -> List[ProxyProduct]:        """Получение списка доступных стран"""        try:            result = await db.execute(                select(ProxyProduct.country_code, ProxyProduct.country_name)                .where(ProxyProduct.is_active.is_(True))                .distinct()                .order_by(ProxyProduct.country_name)            )            # Преобразуем результат в список объектов с атрибутами            countries = []            for row in result.all():                # Создаем простой объект с нужными атрибутами                class Country:                    def __init__(self, country_code, country_name):                        self.country_code = country_code                        self.country_name = country_name                countries.append(Country(row.country_code, row.country_name))            return countries        except Exception as e:            logger.error(f"Error getting available countries: {e}")            return []    # ДОБАВЛЕНО: Дополнительные методы для расширенной функциональности    async def get_products_by_provider(            self,            db: AsyncSession,            *,            provider: str,            skip: int = 0,            limit: int = 20    ) -> List[ProxyProduct]:        """Получение продуктов по провайдеру"""        try:            result = await db.execute(                select(ProxyProduct)                .where(ProxyProduct.provider == provider)                .where(ProxyProduct.is_active.is_(True))                .offset(skip)                .limit(limit)                .order_by(ProxyProduct.created_at.desc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by provider: {e}")            return []    async def get_top_products(            self,            db: AsyncSession,            *,            limit: int = 10,            category: ProxyCategory = None    ) -> List[ProxyProduct]:        """Получение топ продуктов (по популярности/рейтингу)"""        try:            query = select(ProxyProduct).where(ProxyProduct.is_active.is_(True))            if category:                query = query.where(ProxyProduct.proxy_category == category)            # Сортируем по эффективности фарминга и поинтам в час            query = query.order_by(                ProxyProduct.farm_efficiency.desc(),                ProxyProduct.points_per_hour.desc(),                ProxyProduct.created_at.desc()            ).limit(limit)            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting top products: {e}")            return []    async def search_products(            self,            db: AsyncSession,            *,            search_term: str,            skip: int = 0,            limit: int = 20    ) -> List[ProxyProduct]:        """Поиск продуктов по названию и описанию"""        try:            search_pattern = f"%{search_term}%"            result = await db.execute(                select(ProxyProduct)                .where(ProxyProduct.is_active.is_(True))                .where(                    or_(                        ProxyProduct.name.ilike(search_pattern),                        ProxyProduct.description.ilike(search_pattern),                        ProxyProduct.country_name.ilike(search_pattern)                    )                )                .offset(skip)                .limit(limit)                .order_by(ProxyProduct.created_at.desc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error searching products: {e}")            return []    async def get_products_by_price_range(            self,            db: AsyncSession,            *,            min_price: Decimal,            max_price: Decimal,            skip: int = 0,            limit: int = 20    ) -> List[ProxyProduct]:        """Получение продуктов в ценовом диапазоне"""        try:            result = await db.execute(                select(ProxyProduct)                .where(ProxyProduct.is_active.is_(True))                .where(ProxyProduct.price_per_proxy >= min_price)                .where(ProxyProduct.price_per_proxy <= max_price)                .offset(skip)                .limit(limit)                .order_by(ProxyProduct.price_per_proxy.asc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by price range: {e}")            return []    async def get_featured_products(            self,            db: AsyncSession,            *,            limit: int = 5    ) -> List[ProxyProduct]:        """Получение рекомендуемых продуктов"""        try:            # Получаем продукты с лучшими характеристиками            result = await db.execute(                select(ProxyProduct)                .where(ProxyProduct.is_active.is_(True))                .where(ProxyProduct.stock_available > 0)                .order_by(                    ProxyProduct.farm_efficiency.desc(),                    ProxyProduct.uptime_guarantee.desc(),                    ProxyProduct.speed_mbps.desc()                )                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting featured products: {e}")            return []    async def get_products_stats(self, db: AsyncSession) -> dict:        """Получение общей статистики продуктов"""        try:            # Общее количество активных продуктов            total_result = await db.execute(                select(func.count(ProxyProduct.id))                .where(ProxyProduct.is_active.is_(True))            )            total_products = total_result.scalar() or 0            # Средняя цена            avg_price_result = await db.execute(                select(func.avg(ProxyProduct.price_per_proxy))                .where(ProxyProduct.is_active.is_(True))            )            avg_price = avg_price_result.scalar() or Decimal('0')            # Количество стран            countries_result = await db.execute(                select(func.count(distinct(ProxyProduct.country_code)))                .where(ProxyProduct.is_active.is_(True))            )            countries_count = countries_result.scalar() or 0            # Общий доступный сток            stock_result = await db.execute(                select(func.sum(ProxyProduct.stock_available))                .where(ProxyProduct.is_active.is_(True))            )            total_stock = stock_result.scalar() or 0            return {                "total_products": total_products,                "average_price": str(avg_price),                "countries_available": countries_count,                "total_stock": total_stock            }        except Exception as e:            logger.error(f"Error getting products stats: {e}")            return {                "total_products": 0,                "average_price": "0.00",                "countries_available": 0,                "total_stock": 0            }proxy_product_crud = CRUDProxyProduct(ProxyProduct)