from typing import Optional, Listfrom sqlalchemy import select, and_, distinctfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.crud.base import CRUDBasefrom app.models.models import ProxyProduct, ProxyType, SessionType, ProviderTypefrom app.schemas.proxy_product import ProxyProductCreate, ProxyProductUpdateclass CRUDProxyProduct(CRUDBase[ProxyProduct, ProxyProductCreate, ProxyProductUpdate]):    @staticmethod    async def get_active_products(            db: AsyncSession,            *,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить активные продукты"""        result = await db.execute(            select(ProxyProduct).where(                and_(                    ProxyProduct.is_active == True,                    ProxyProduct.stock_available > 0                )            ).offset(skip).limit(limit)        )        return result.scalars().all()    @staticmethod    async def get_by_filters(            db: AsyncSession,            *,            proxy_type: Optional[ProxyType] = None,            session_type: Optional[SessionType] = None,            provider: Optional[ProviderType] = None,            country_code: Optional[str] = None,            city: Optional[str] = None,            featured_only: bool = False,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить продукты по фильтрам"""        query = select(ProxyProduct).where(ProxyProduct.is_active == True)        if proxy_type:            query = query.where(ProxyProduct.proxy_type == proxy_type)        if session_type:            query = query.where(ProxyProduct.session_type == session_type)        if provider:            query = query.where(ProxyProduct.provider == provider)        if country_code:            query = query.where(ProxyProduct.country_code == country_code)        if city:            query = query.where(ProxyProduct.city == city)        if featured_only:            query = query.where(ProxyProduct.is_featured == True)        result = await db.execute(query.offset(skip).limit(limit))        return result.scalars().all()    @staticmethod    async def get_by_provider(            db: AsyncSession,            *,            provider: ProviderType,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить продукты конкретного провайдера"""        result = await db.execute(            select(ProxyProduct).where(                and_(                    ProxyProduct.provider == provider,                    ProxyProduct.is_active == True                )            ).offset(skip).limit(limit)        )        return result.scalars().all()    @staticmethod    async def get_countries(db: AsyncSession) -> List[dict]:        """Получить список доступных стран"""        result = await db.execute(            select(                distinct(ProxyProduct.country_code),                ProxyProduct.country_name            ).where(ProxyProduct.is_active == True)        )        return [{"code": row[0], "name": row[1]} for row in result.all()]    @staticmethod    async def get_cities_by_country(db: AsyncSession, *, country_code: str) -> List[str]:        """Получить список городов для страны"""        result = await db.execute(            select(distinct(ProxyProduct.city)).where(                and_(                    ProxyProduct.country_code == country_code,                    ProxyProduct.is_active == True,                    ProxyProduct.city.isnot(None)                )            )        )        return [row[0] for row in result.all() if row[0]]    async def update_stock(self, db: AsyncSession, *, product_id: int, quantity: int) -> Optional[ProxyProduct]:        """Обновить количество в наличии"""        product = await self.get(db, id=product_id)        if product:            product.stock_available = max(0, product.stock_available - quantity)            await db.commit()            await db.refresh(product)        return product    async def check_availability(self, db: AsyncSession, *, product_id: int, quantity: int) -> bool:        """Проверить доступность товара в нужном количестве"""        product = await self.get(db, id=product_id)        if not product or not product.is_active:            return False        return product.stock_available >= quantityproxy_product_crud = CRUDProxyProduct(ProxyProduct)