"""CRUD операции для продуктов прокси.Содержит методы для управления каталогом прокси-продуктов,фильтрации, поиска и получения статистики по продуктам."""import loggingfrom datetime import datetime, timezonefrom decimal import Decimalfrom typing import List, Optional, Dict, Anyfrom sqlalchemy import select, func, or_, distinct, and_, updatefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.crud.base import CRUDBasefrom app.models.models import ProxyProduct, ProxyCategory, ProviderTypefrom app.schemas.proxy_product import (    ProxyProductCreate, ProxyProductUpdate, ProductFilter,    ProductAvailabilityRequest, ProductBulkUpdateRequest)logger = logging.getLogger(__name__)class CountryInfo:    """Простой класс для представления информации о стране."""    def __init__(self, country_code: str, country_name: str, products_count: int = 0):        self.country_code = country_code        self.country_name = country_name        self.products_count = products_countclass CRUDProxyProduct(CRUDBase[ProxyProduct, ProxyProductCreate, ProxyProductUpdate]):    """    CRUD для управления продуктами прокси.    Обеспечивает расширенную функциональность для работы с каталогом прокси:    - Фильтрация и поиск продуктов    - Управление наличием и ценами    - Статистика и аналитика    - Рекомендации и топ продукты    """    async def get_products_with_filter(        self,        db: AsyncSession,        *,        filter_params: ProductFilter,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов с комплексной фильтрацией.        Args:            db: Сессия базы данных            filter_params: Параметры фильтрации            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Отфильтрованный список продуктов        """        try:            # Валидация параметров пагинации            if skip < 0:                skip = 0            if limit <= 0 or limit > 100:                limit = 20            query = select(ProxyProduct).where(ProxyProduct.is_active.is_(True))            # Применяем фильтры            query = self._apply_filters(query, filter_params)            # Применяем сортировку            query = self._apply_sorting(query, filter_params.sort)            # Пагинация            query = query.offset(skip).limit(limit)            result = await db.execute(query)            products = list(result.scalars().all())            logger.debug(f"Found {len(products)} products with filters")            return products        except Exception as e:            logger.error(f"Error in get_products_with_filter: {e}")            return []    async def count_products_with_filter(        self,        db: AsyncSession,        *,        filter_params: ProductFilter    ) -> int:        """        Подсчет продуктов с применением фильтров.        Args:            db: Сессия базы данных            filter_params: Параметры фильтрации        Returns:            int: Количество продуктов соответствующих фильтрам        """        try:            query = select(func.count(ProxyProduct.id)).where(ProxyProduct.is_active.is_(True))            # Применяем те же фильтры            query = self._apply_filters(query, filter_params)            result = await db.execute(query)            count = result.scalar() or 0            logger.debug(f"Counted {count} products with filters")            return count        except Exception as e:            logger.error(f"Error in count_products_with_filter: {e}")            return 0    def _apply_filters(self, query, filter_params: ProductFilter):        """        Применение фильтров к запросу.        Args:            query: SQLAlchemy запрос            filter_params: Параметры фильтрации        Returns:            Модифицированный запрос        """        # Поиск по тексту        if filter_params.search:            search_term = f"%{filter_params.search.strip()}%"            query = query.where(                or_(                    ProxyProduct.name.ilike(search_term),                    ProxyProduct.description.ilike(search_term),                    ProxyProduct.country_name.ilike(search_term)                )            )        # Фильтр по категории        if filter_params.proxy_category:            query = query.where(ProxyProduct.proxy_category == filter_params.proxy_category)        # Фильтр по типу прокси        if filter_params.proxy_type:            query = query.where(ProxyProduct.proxy_type == filter_params.proxy_type)        # Фильтр по провайдеру        if filter_params.provider:            query = query.where(ProxyProduct.provider == filter_params.provider)        # Фильтр по типу сессии        if filter_params.session_type:            query = query.where(ProxyProduct.session_type == filter_params.session_type)        # Фильтр по стране        if filter_params.country_code:            query = query.where(ProxyProduct.country_code == filter_params.country_code.upper())        # Фильтр по городу        if filter_params.city:            query = query.where(ProxyProduct.city.ilike(f"%{filter_params.city}%"))        # Ценовые фильтры        if filter_params.min_price is not None and filter_params.min_price > 0:            query = query.where(ProxyProduct.price_per_proxy >= filter_params.min_price)        if filter_params.max_price is not None and filter_params.max_price > 0:            query = query.where(ProxyProduct.price_per_proxy <= filter_params.max_price)        # Фильтры по длительности        if filter_params.min_duration:            query = query.where(ProxyProduct.duration_days >= filter_params.min_duration)        if filter_params.max_duration:            query = query.where(ProxyProduct.duration_days <= filter_params.max_duration)        # Фильтры по потокам        if filter_params.min_threads:            query = query.where(ProxyProduct.max_threads >= filter_params.min_threads)        if filter_params.max_threads:            query = query.where(ProxyProduct.max_threads <= filter_params.max_threads)        # Технические фильтры        if filter_params.min_speed:            query = query.where(ProxyProduct.speed_mbps >= filter_params.min_speed)        if filter_params.min_uptime:            query = query.where(ProxyProduct.uptime_guarantee >= filter_params.min_uptime)        # Фильтр по наличию        if filter_params.in_stock_only:            query = query.where(ProxyProduct.stock_available > 0)        # Фильтр по рекомендуемым        if filter_params.featured_only:            query = query.where(ProxyProduct.is_featured.is_(True))        return query    def _apply_sorting(self, query, sort_param: str):        """        Применение сортировки к запросу.        Args:            query: SQLAlchemy запрос            sort_param: Параметр сортировки        Returns:            Модифицированный запрос с сортировкой        """        if sort_param == "price_asc":            return query.order_by(ProxyProduct.price_per_proxy.asc())        elif sort_param == "price_desc":            return query.order_by(ProxyProduct.price_per_proxy.desc())        elif sort_param == "name_asc":            return query.order_by(ProxyProduct.name.asc())        elif sort_param == "name_desc":            return query.order_by(ProxyProduct.name.desc())        elif sort_param == "speed_desc":            return query.order_by(ProxyProduct.speed_mbps.desc().nulls_last())        elif sort_param == "uptime_desc":            return query.order_by(ProxyProduct.uptime_guarantee.desc().nulls_last())        elif sort_param == "created_at_asc":            return query.order_by(ProxyProduct.created_at.asc())        else:  # created_at_desc по умолчанию            return query.order_by(ProxyProduct.created_at.desc())    async def get_products_by_category(        self,        db: AsyncSession,        *,        category: ProxyCategory,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов по категории.        Args:            db: Сессия базы данных            category: Категория прокси            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов в категории        """        try:            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.proxy_category == category,                        ProxyProduct.is_active.is_(True)                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by category {category}: {e}")            return []    async def count_products_by_category(        self,        db: AsyncSession,        *,        category: ProxyCategory    ) -> int:        """        Подсчет продуктов в категории.        Args:            db: Сессия базы данных            category: Категория прокси        Returns:            int: Количество продуктов в категории        """        try:            result = await db.execute(                select(func.count(ProxyProduct.id))                .where(                    and_(                        ProxyProduct.proxy_category == category,                        ProxyProduct.is_active.is_(True)                    )                )            )            return result.scalar() or 0        except Exception as e:            logger.error(f"Error counting products by category {category}: {e}")            return 0    async def get_available_countries(self, db: AsyncSession) -> List[CountryInfo]:        """        Получение списка доступных стран.        Args:            db: Сессия базы данных        Returns:            List[CountryInfo]: Список стран с кодами и названиями        """        try:            result = await db.execute(                select(                    ProxyProduct.country_code,                    ProxyProduct.country_name,                    func.count(ProxyProduct.id).label('products_count')                )                .where(ProxyProduct.is_active.is_(True))                .group_by(ProxyProduct.country_code, ProxyProduct.country_name)                .order_by(ProxyProduct.country_name)            )            countries = []            for row in result.all():                countries.append(CountryInfo(                    row.country_code,                    row.country_name,                    row.products_count                ))            logger.debug(f"Found {len(countries)} available countries")            return countries        except Exception as e:            logger.error(f"Error getting available countries: {e}")            return []    async def get_products_by_provider(        self,        db: AsyncSession,        *,        provider: ProviderType,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов по провайдеру.        Args:            db: Сессия базы данных            provider: Провайдер прокси            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов провайдера        """        try:            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.provider == provider,                        ProxyProduct.is_active.is_(True)                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by provider {provider}: {e}")            return []    async def get_featured_products(        self,        db: AsyncSession,        *,        limit: int = 5,        category: Optional[ProxyCategory] = None    ) -> List[ProxyProduct]:        """        Получение рекомендуемых продуктов.        Args:            db: Сессия базы данных            limit: Максимальное количество продуктов            category: Фильтр по категории (опционально)        Returns:            List[ProxyProduct]: Список рекомендуемых продуктов        """        try:            query = select(ProxyProduct).where(                and_(                    ProxyProduct.is_active.is_(True),                    ProxyProduct.stock_available > 0,                    ProxyProduct.is_featured.is_(True)                )            )            if category:                query = query.where(ProxyProduct.proxy_category == category)            query = query.order_by(                ProxyProduct.uptime_guarantee.desc().nulls_last(),                ProxyProduct.speed_mbps.desc().nulls_last(),                ProxyProduct.created_at.desc()            ).limit(min(limit, 20))            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting featured products: {e}")            return []    async def search_products(        self,        db: AsyncSession,        *,        search_term: str,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Поиск продуктов по названию, описанию и стране.        Args:            db: Сессия базы данных            search_term: Поисковый термин            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список найденных продуктов        """        try:            if not search_term or len(search_term.strip()) < 2:                return []            search_pattern = f"%{search_term.strip()}%"            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        or_(                            ProxyProduct.name.ilike(search_pattern),                            ProxyProduct.description.ilike(search_pattern),                            ProxyProduct.country_name.ilike(search_pattern),                            ProxyProduct.city.ilike(search_pattern)                        )                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            products = list(result.scalars().all())            logger.debug(f"Search '{search_term}' found {len(products)} products")            return products        except Exception as e:            logger.error(f"Error searching products with term '{search_term}': {e}")            return []    async def get_products_by_price_range(        self,        db: AsyncSession,        *,        min_price: Decimal,        max_price: Decimal,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов в ценовом диапазоне.        Args:            db: Сессия базы данных            min_price: Минимальная цена            max_price: Максимальная цена            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов в ценовом диапазоне        """        try:            # Валидация ценовых параметров            if min_price < 0 or max_price < 0 or min_price > max_price:                logger.warning(f"Invalid price range: {min_price} - {max_price}")                return []            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        ProxyProduct.price_per_proxy >= min_price,                        ProxyProduct.price_per_proxy <= max_price                    )                )                .order_by(ProxyProduct.price_per_proxy.asc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by price range {min_price}-{max_price}: {e}")            return []    async def check_product_availability(        self,        db: AsyncSession,        *,        availability_request: ProductAvailabilityRequest    ) -> Dict[str, Any]:        """        Проверка доступности продукта.        Args:            db: Сессия базы данных            availability_request: Запрос проверки доступности        Returns:            Dict[str, Any]: Информация о доступности        """        try:            product = await self.get(db, id=availability_request.product_id)            if not product:                return {                    "product_id": availability_request.product_id,                    "requested_quantity": availability_request.quantity,                    "is_available": False,                    "stock_available": 0,                    "max_quantity": 0,                    "price_per_unit": "0.00000000",                    "total_price": "0.00000000",                    "currency": "USD",                    "message": "Product not found"                }            if not product.is_active:                return {                    "product_id": availability_request.product_id,                    "requested_quantity": availability_request.quantity,                    "is_available": False,                    "stock_available": product.stock_available,                    "max_quantity": product.max_quantity,                    "price_per_unit": str(product.price_per_proxy),                    "total_price": "0.00000000",                    "currency": "USD",                    "message": "Product is not active"                }            # Проверяем количество            requested_qty = availability_request.quantity            is_available = (                    product.min_quantity <= requested_qty <= product.max_quantity and                    requested_qty <= product.stock_available            )            total_price = product.price_per_proxy * requested_qty if is_available else Decimal('0')            if not is_available:                if requested_qty < product.min_quantity:                    message = f"Minimum quantity is {product.min_quantity}"                elif requested_qty > product.max_quantity:                    message = f"Maximum quantity is {product.max_quantity}"                elif requested_qty > product.stock_available:                    message = f"Only {product.stock_available} items available"                else:                    message = "Not available"            else:                message = "Available"            return {                "product_id": availability_request.product_id,                "requested_quantity": requested_qty,                "is_available": is_available,                "stock_available": product.stock_available,                "max_quantity": product.max_quantity,                "price_per_unit": str(product.price_per_proxy),                "total_price": str(total_price),                "currency": "USD",                "message": message            }        except Exception as e:            logger.error(f"Error checking product availability: {e}")            return {                "product_id": availability_request.product_id,                "requested_quantity": availability_request.quantity,                "is_available": False,                "stock_available": 0,                "max_quantity": 0,                "price_per_unit": "0.00000000",                "total_price": "0.00000000",                "currency": "USD",                "message": "Error checking availability"            }    async def get_products_stats(self, db: AsyncSession) -> Dict[str, Any]:        """        Получение общей статистики продуктов.        Args:            db: Сессия базы данных        Returns:            Dict[str, Any]: Статистика продуктов        """        try:            # Общее количество активных продуктов            total_result = await db.execute(                select(func.count(ProxyProduct.id))                .where(ProxyProduct.is_active.is_(True))            )            total_products = total_result.scalar() or 0            # Активные продукты            active_products = total_products            # Рекомендуемые продукты            featured_result = await db.execute(                select(func.count(ProxyProduct.id))                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        ProxyProduct.is_featured.is_(True)                    )                )            )            featured_products = featured_result.scalar() or 0            # Средняя цена            avg_price_result = await db.execute(                select(func.avg(ProxyProduct.price_per_proxy))                .where(ProxyProduct.is_active.is_(True))            )            avg_price = avg_price_result.scalar() or Decimal('0')            # Количество стран            countries_result = await db.execute(                select(func.count(distinct(ProxyProduct.country_code)))                .where(ProxyProduct.is_active.is_(True))            )            countries_count = countries_result.scalar() or 0            # Общий доступный сток            stock_result = await db.execute(                select(func.sum(ProxyProduct.stock_available))                .where(ProxyProduct.is_active.is_(True))            )            total_stock = stock_result.scalar() or 0            # Статистика по категориям            categories_result = await db.execute(                select(                    ProxyProduct.proxy_category,                    func.count(ProxyProduct.id)                )                .where(ProxyProduct.is_active.is_(True))                .group_by(ProxyProduct.proxy_category)            )            categories_stats = {category.value: count for category, count in categories_result.all()}            # Статистика по провайдерам            providers_result = await db.execute(                select(                    ProxyProduct.provider,                    func.count(ProxyProduct.id)                )                .where(ProxyProduct.is_active.is_(True))                .group_by(ProxyProduct.provider)            )            providers_stats = {provider.value: count for provider, count in providers_result.all()}            return {                "total_products": total_products,                "active_products": active_products,                "featured_products": featured_products,                "total_stock": total_stock,                "average_price": str(avg_price.quantize(Decimal('0.01'))),                "countries_available": countries_count,                "categories_breakdown": categories_stats,                "providers_breakdown": providers_stats            }        except Exception as e:            logger.error(f"Error getting products stats: {e}")            return {                "total_products": 0,                "active_products": 0,                "featured_products": 0,                "total_stock": 0,                "average_price": "0.00",                "countries_available": 0,                "categories_breakdown": {},                "providers_breakdown": {}            }    async def update_stock(        self,        db: AsyncSession,        *,        product_id: int,        stock_change: int    ) -> Optional[ProxyProduct]:        """        Обновление остатков продукта.        Args:            db: Сессия базы данных            product_id: ID продукта            stock_change: Изменение остатка (может быть отрицательным)        Returns:            Optional[ProxyProduct]: Обновленный продукт или None        """        try:            product = await self.get(db, id=product_id)            if not product:                logger.warning(f"Product {product_id} not found for stock update")                return None            old_stock = product.stock_available            new_stock = max(0, old_stock + stock_change)            product.stock_available = new_stock            product.updated_at = datetime.now(timezone.utc)            await db.commit()            await db.refresh(product)            logger.info(f"Updated stock for product {product_id}: {old_stock} -> {new_stock} (change: {stock_change})")            return product        except Exception as e:            await db.rollback()            logger.error(f"Error updating stock for product {product_id}: {e}")            return None    async def bulk_update_products(        self,        db: AsyncSession,        *,        bulk_request: ProductBulkUpdateRequest    ) -> Dict[str, Any]:        """        Массовое обновление продуктов.        Args:            db: Сессия базы данных            bulk_request: Запрос массового обновления        Returns:            Dict[str, Any]: Результат операции        """        try:            processed = 0            errors = []            if bulk_request.operation == "activate":                result = await db.execute(                    update(ProxyProduct)                    .where(ProxyProduct.id.in_(bulk_request.product_ids))                    .values(is_active=True, updated_at=datetime.now(timezone.utc))                )                processed = result.rowcount or 0            elif bulk_request.operation == "deactivate":                result = await db.execute(                    update(ProxyProduct)                    .where(ProxyProduct.id.in_(bulk_request.product_ids))                    .values(is_active=False, updated_at=datetime.now(timezone.utc))                )                processed = result.rowcount or 0            elif bulk_request.operation == "feature":                result = await db.execute(                    update(ProxyProduct)                    .where(ProxyProduct.id.in_(bulk_request.product_ids))                    .values(is_featured=True, updated_at=datetime.now(timezone.utc))                )                processed = result.rowcount or 0            elif bulk_request.operation == "unfeature":                result = await db.execute(                    update(ProxyProduct)                    .where(ProxyProduct.id.in_(bulk_request.product_ids))                    .values(is_featured=False, updated_at=datetime.now(timezone.utc))                )                processed = result.rowcount or 0            elif bulk_request.operation == "update_stock":                if bulk_request.stock_change is None:                    raise ValueError("stock_change is required for update_stock operation")                for product_id in bulk_request.product_ids:                    try:                        await self.update_stock(db, product_id=product_id, stock_change=bulk_request.stock_change)                        processed += 1                    except Exception as e:                        errors.append(f"Product {product_id}: {str(e)}")            await db.commit()            return {                "success": True,                "processed": processed,                "total": len(bulk_request.product_ids),                "errors": errors            }        except Exception as e:            await db.rollback()            logger.error(f"Error in bulk update: {e}")            return {                "success": False,                "processed": 0,                "total": len(bulk_request.product_ids),                "errors": [str(e)]            }proxy_product_crud = CRUDProxyProduct(ProxyProduct)