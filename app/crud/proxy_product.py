from typing import Optional, List, Dict, Anyfrom sqlalchemy import select, and_, distinct, funcfrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.crud.base import CRUDBasefrom app.models.models import ProxyProduct, ProxyType, ProxyCategory, SessionType, ProviderTypefrom app.schemas.proxy_product import ProxyProductCreate, ProxyProductUpdateclass CRUDProxyProduct(CRUDBase[ProxyProduct, ProxyProductCreate, ProxyProductUpdate]):    @staticmethod    async def get_active_products(            db: AsyncSession,            *,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить активные продукты"""        result = await db.execute(            select(ProxyProduct).where(                and_(                    ProxyProduct.is_active.is_(True),                    ProxyProduct.stock_available > 0                )            ).offset(skip).limit(limit)        )        return list(result.scalars().all())    @staticmethod    async def get_by_filters(            db: AsyncSession,            *,            proxy_type: Optional[ProxyType] = None,            proxy_category: Optional[ProxyCategory] = None,            session_type: Optional[SessionType] = None,            provider: Optional[ProviderType] = None,            country_code: Optional[str] = None,            city: Optional[str] = None,            featured_only: bool = False,            min_speed: Optional[int] = None,            min_uptime: Optional[float] = None,            # НОВЫЕ ФИЛЬТРЫ для фарминга            min_points_per_hour: Optional[int] = None,            min_farm_efficiency: Optional[float] = None,            auto_claim_only: Optional[bool] = None,            multi_account_only: Optional[bool] = None,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить продукты по фильтрам"""        query = select(ProxyProduct).where(ProxyProduct.is_active.is_(True))        if proxy_type:            query = query.where(ProxyProduct.proxy_type == proxy_type)        if proxy_category:            query = query.where(ProxyProduct.proxy_category == proxy_category)        if session_type:            query = query.where(ProxyProduct.session_type == session_type)        if provider:            query = query.where(ProxyProduct.provider == provider)        if country_code:            query = query.where(ProxyProduct.country_code == country_code)        if city:            query = query.where(ProxyProduct.city == city)        if featured_only:            query = query.where(ProxyProduct.is_featured.is_(True))        if min_speed:            query = query.where(ProxyProduct.speed_mbps >= min_speed)        if min_uptime:            query = query.where(ProxyProduct.uptime_guarantee >= min_uptime)        # НОВЫЕ ФИЛЬТРЫ для фарминга        if min_points_per_hour:            query = query.where(ProxyProduct.points_per_hour >= min_points_per_hour)        if min_farm_efficiency:            query = query.where(ProxyProduct.farm_efficiency >= min_farm_efficiency)        if auto_claim_only:            query = query.where(ProxyProduct.auto_claim.is_(True))        if multi_account_only:            query = query.where(ProxyProduct.multi_account_support.is_(True))        result = await db.execute(query.offset(skip).limit(limit))        return list(result.scalars().all())    @staticmethod    async def get_by_provider(            db: AsyncSession,            *,            provider: ProviderType,            skip: int = 0,            limit: int = 100    ) -> List[ProxyProduct]:        """Получить продукты конкретного провайдера"""        result = await db.execute(            select(ProxyProduct).where(                and_(                    ProxyProduct.provider == provider,                    ProxyProduct.is_active.is_(True)                )            ).offset(skip).limit(limit)        )        return list(result.scalars().all())    @staticmethod    async def get_countries(db: AsyncSession) -> List[dict]:        """Получить список доступных стран"""        result = await db.execute(            select(                distinct(ProxyProduct.country_code),                ProxyProduct.country_name            ).where(ProxyProduct.is_active.is_(True))        )        return [{"code": row[0], "name": row[1]} for row in result.all()]    @staticmethod    async def get_cities_by_country(db: AsyncSession, *, country_code: str) -> List[str]:        """Получить список городов для страны"""        result = await db.execute(            select(distinct(ProxyProduct.city)).where(                and_(                    ProxyProduct.country_code == country_code,                    ProxyProduct.is_active.is_(True),                    ProxyProduct.city.isnot(None)                )            )        )        return [row[0] for row in result.all() if row[0]]    @staticmethod    async def get_categories_stats(db: AsyncSession) -> Dict[str, Any]:        """Получение статистики по категориям прокси"""        result = await db.execute(            select(                ProxyProduct.proxy_category,                func.count(ProxyProduct.id).label('count'),                func.min(ProxyProduct.price_per_proxy).label('min_price'),                func.max(ProxyProduct.price_per_proxy).label('max_price'),                func.avg(ProxyProduct.price_per_proxy).label('avg_price')            )            .where(ProxyProduct.is_active.is_(True))            .group_by(ProxyProduct.proxy_category)        )        stats = {}        for row in result:            stats[row.proxy_category] = {                'count': row.count,                'min_price': float(row.min_price),                'max_price': float(row.max_price),                'avg_price': float(row.avg_price)            }        return stats    async def update_stock(self, db: AsyncSession, *, product_id: int, quantity: int) -> Optional[ProxyProduct]:        """Обновить количество в наличии"""        product = await self.get(db, obj_id=product_id)        if product:            product.stock_available = max(0, product.stock_available - quantity)            await db.commit()            await db.refresh(product)        return product    async def check_availability(self, db: AsyncSession, *, product_id: int, quantity: int) -> bool:        """Проверить доступность товара в нужном количестве"""        product = await self.get(db, obj_id=product_id)        if not product or not product.is_active:            return False        return product.stock_available >= quantityproxy_product_crud = CRUDProxyProduct(ProxyProduct)