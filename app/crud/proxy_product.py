"""CRUD операции для продуктов прокси.Содержит методы для управления каталогом прокси-продуктов,фильтрации, поиска и получения статистики по продуктам."""import loggingfrom decimal import Decimalfrom typing import List, Optional, Dict, Anyfrom sqlalchemy import select, func, or_, distinct, and_from sqlalchemy.ext.asyncio import AsyncSessionfrom app.crud.base import CRUDBasefrom app.models.models import ProxyProduct, ProxyCategory, ProviderTypefrom app.schemas.proxy_product import ProxyProductCreate, ProxyProductUpdate, ProductFilterlogger = logging.getLogger(__name__)class CountryInfo:    """Простой класс для представления информации о стране."""    def __init__(self, country_code: str, country_name: str):        self.country_code = country_code        self.country_name = country_nameclass CRUDProxyProduct(CRUDBase[ProxyProduct, ProxyProductCreate, ProxyProductUpdate]):    """    CRUD для управления продуктами прокси.    Обеспечивает расширенную функциональность для работы с каталогом прокси:    - Фильтрация и поиск продуктов    - Управление наличием и ценами    - Статистика и аналитика    - Рекомендации и топ продукты    """    async def get_products_with_filter(        self,        db: AsyncSession,        *,        filter_params: ProductFilter,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов с комплексной фильтрацией.        Args:            db: Сессия базы данных            filter_params: Параметры фильтрации            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Отфильтрованный список продуктов        """        try:            # Валидация параметров пагинации            if skip < 0:                skip = 0            if limit <= 0 or limit > 100:                limit = 20            query = select(ProxyProduct).where(ProxyProduct.is_active.is_(True))            # Применяем фильтры            query = self._apply_filters(query, filter_params)            # Применяем сортировку            query = self._apply_sorting(query, filter_params.sort)            # Пагинация            query = query.offset(skip).limit(limit)            result = await db.execute(query)            products = list(result.scalars().all())            logger.debug(f"Found {len(products)} products with filters")            return products        except Exception as e:            logger.error(f"Error in get_products_with_filter: {e}")            return []    async def count_products_with_filter(        self,        db: AsyncSession,        *,        filter_params: ProductFilter    ) -> int:        """        Подсчет продуктов с применением фильтров.        Args:            db: Сессия базы данных            filter_params: Параметры фильтрации        Returns:            int: Количество продуктов соответствующих фильтрам        """        try:            query = select(func.count(ProxyProduct.id)).where(ProxyProduct.is_active.is_(True))            # Применяем те же фильтры            query = self._apply_filters(query, filter_params)            result = await db.execute(query)            count = result.scalar() or 0            logger.debug(f"Counted {count} products with filters")            return count        except Exception as e:            logger.error(f"Error in count_products_with_filter: {e}")            return 0    @staticmethod    def _apply_filters(query, filter_params: ProductFilter):        """        Применение фильтров к запросу.        Args:            query: SQLAlchemy запрос            filter_params: Параметры фильтрации        Returns:            Модифицированный запрос        """        # Поиск по тексту        if filter_params.search:            search_term = f"%{filter_params.search.strip()}%"            query = query.where(                or_(                    ProxyProduct.name.ilike(search_term),                    ProxyProduct.description.ilike(search_term),                    ProxyProduct.country_name.ilike(search_term)                )            )        # Фильтр по категории        if filter_params.proxy_category:            query = query.where(ProxyProduct.proxy_category == filter_params.proxy_category)        # Фильтр по типу прокси        if filter_params.proxy_type:            query = query.where(ProxyProduct.proxy_type == filter_params.proxy_type)        # Фильтр по провайдеру        if filter_params.provider:            query = query.where(ProxyProduct.provider == filter_params.provider)        # Фильтр по стране        if filter_params.country:            query = query.where(ProxyProduct.country_code == filter_params.country)        # Ценовые фильтры        if filter_params.min_price is not None and filter_params.min_price > 0:            query = query.where(ProxyProduct.price_per_proxy >= Decimal(str(filter_params.min_price)))        if filter_params.max_price is not None and filter_params.max_price > 0:            query = query.where(ProxyProduct.price_per_proxy <= Decimal(str(filter_params.max_price)))        # Фильтры для фарминга        if filter_params.min_points_per_hour is not None and filter_params.min_points_per_hour > 0:            query = query.where(ProxyProduct.points_per_hour >= filter_params.min_points_per_hour)        if filter_params.auto_claim_only:            query = query.where(ProxyProduct.auto_claim.is_(True))        if filter_params.min_farm_efficiency is not None and filter_params.min_farm_efficiency > 0:            query = query.where(ProxyProduct.farm_efficiency >= Decimal(str(filter_params.min_farm_efficiency)))        if filter_params.multi_account_only:            query = query.where(ProxyProduct.multi_account_support.is_(True))        # Технические фильтры        if filter_params.min_speed is not None and filter_params.min_speed > 0:            query = query.where(ProxyProduct.speed_mbps >= filter_params.min_speed)        if filter_params.min_uptime is not None and filter_params.min_uptime > 0:            query = query.where(ProxyProduct.uptime_guarantee >= Decimal(str(filter_params.min_uptime)))        # Фильтр по наличию        if filter_params.in_stock_only:            query = query.where(ProxyProduct.stock_available > 0)        return query    @staticmethod    def _apply_sorting(query, sort_param: Optional[str]):        """        Применение сортировки к запросу.        Args:            query: SQLAlchemy запрос            sort_param: Параметр сортировки        Returns:            Модифицированный запрос с сортировкой        """        if sort_param == "price_asc":            return query.order_by(ProxyProduct.price_per_proxy.asc())        elif sort_param == "price_desc":            return query.order_by(ProxyProduct.price_per_proxy.desc())        elif sort_param == "name_asc":            return query.order_by(ProxyProduct.name.asc())        elif sort_param == "name_desc":            return query.order_by(ProxyProduct.name.desc())        elif sort_param == "points_desc":            return query.order_by(ProxyProduct.points_per_hour.desc().nulls_last())        elif sort_param == "efficiency_desc":            return query.order_by(ProxyProduct.farm_efficiency.desc().nulls_last())        elif sort_param == "speed_desc":            return query.order_by(ProxyProduct.speed_mbps.desc().nulls_last())        elif sort_param == "uptime_desc":            return query.order_by(ProxyProduct.uptime_guarantee.desc().nulls_last())        else:  # created_at_desc по умолчанию            return query.order_by(ProxyProduct.created_at.desc())    @staticmethod    async def get_products_by_category(            db: AsyncSession,        *,        category: ProxyCategory,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов по категории.        Args:            db: Сессия базы данных            category: Категория прокси            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов в категории        """        try:            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.proxy_category == category,                        ProxyProduct.is_active.is_(True)                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by category {category}: {e}")            return []    @staticmethod    async def count_products_by_category(            db: AsyncSession,        category: ProxyCategory    ) -> int:        """        Подсчет продуктов в категории.        Args:            db: Сессия базы данных            category: Категория прокси        Returns:            int: Количество продуктов в категории        """        try:            result = await db.execute(                select(func.count(ProxyProduct.id))                .where(                    and_(                        ProxyProduct.proxy_category == category,                        ProxyProduct.is_active.is_(True)                    )                )            )            return result.scalar() or 0        except Exception as e:            logger.error(f"Error counting products by category {category}: {e}")            return 0    @staticmethod    async def get_available_countries(db: AsyncSession) -> List[CountryInfo]:        """        Получение списка доступных стран.        Args:            db: Сессия базы данных        Returns:            List[CountryInfo]: Список стран с кодами и названиями        """        try:            result = await db.execute(                select(                    distinct(ProxyProduct.country_code),                    ProxyProduct.country_name                )                .where(ProxyProduct.is_active.is_(True))                .order_by(ProxyProduct.country_name)            )            countries = []            seen_codes = set()            for row in result.all():                if row.country_code not in seen_codes:                    countries.append(CountryInfo(row.country_code, row.country_name))                    seen_codes.add(row.country_code)            logger.debug(f"Found {len(countries)} available countries")            return countries        except Exception as e:            logger.error(f"Error getting available countries: {e}")            return []    @staticmethod    async def get_products_by_provider(            db: AsyncSession,        *,        provider: ProviderType,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов по провайдеру.        Args:            db: Сессия базы данных            provider: Провайдер прокси            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов провайдера        """        try:            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.provider == provider,                        ProxyProduct.is_active.is_(True)                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by provider {provider}: {e}")            return []    @staticmethod    async def get_top_products(            db: AsyncSession,        *,        limit: int = 10,        category: Optional[ProxyCategory] = None    ) -> List[ProxyProduct]:        """        Получение топ продуктов по эффективности.        Args:            db: Сессия базы данных            limit: Максимальное количество продуктов            category: Фильтр по категории (опционально)        Returns:            List[ProxyProduct]: Список топ продуктов        """        try:            query = select(ProxyProduct).where(                and_(                    ProxyProduct.is_active.is_(True),                    ProxyProduct.stock_available > 0                )            )            if category:                query = query.where(ProxyProduct.proxy_category == category)            # Сортируем по эффективности фарминга и поинтам в час            query = query.order_by(                ProxyProduct.farm_efficiency.desc().nulls_last(),                ProxyProduct.points_per_hour.desc().nulls_last(),                ProxyProduct.uptime_guarantee.desc().nulls_last(),                ProxyProduct.created_at.desc()            ).limit(min(limit, 50))  # Ограничиваем максимум 50 продуктами            result = await db.execute(query)            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting top products: {e}")            return []    @staticmethod    async def search_products(            db: AsyncSession,        *,        search_term: str,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Поиск продуктов по названию, описанию и стране.        Args:            db: Сессия базы данных            search_term: Поисковый термин            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список найденных продуктов        """        try:            if not search_term or len(search_term.strip()) < 2:                return []            search_pattern = f"%{search_term.strip()}%"            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        or_(                            ProxyProduct.name.ilike(search_pattern),                            ProxyProduct.description.ilike(search_pattern),                            ProxyProduct.country_name.ilike(search_pattern)                        )                    )                )                .order_by(ProxyProduct.created_at.desc())                .offset(skip)                .limit(limit)            )            products = list(result.scalars().all())            logger.debug(f"Search '{search_term}' found {len(products)} products")            return products        except Exception as e:            logger.error(f"Error searching products with term '{search_term}': {e}")            return []    @staticmethod    async def get_products_by_price_range(            db: AsyncSession,        *,        min_price: Decimal,        max_price: Decimal,        skip: int = 0,        limit: int = 20    ) -> List[ProxyProduct]:        """        Получение продуктов в ценовом диапазоне.        Args:            db: Сессия базы данных            min_price: Минимальная цена            max_price: Максимальная цена            skip: Количество пропускаемых записей            limit: Максимальное количество записей        Returns:            List[ProxyProduct]: Список продуктов в ценовом диапазоне        """        try:            # Валидация ценовых параметров            if min_price < 0 or max_price < 0 or min_price > max_price:                logger.warning(f"Invalid price range: {min_price} - {max_price}")                return []            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        ProxyProduct.price_per_proxy >= min_price,                        ProxyProduct.price_per_proxy <= max_price                    )                )                .order_by(ProxyProduct.price_per_proxy.asc())                .offset(skip)                .limit(limit)            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting products by price range {min_price}-{max_price}: {e}")            return []    @staticmethod    async def get_featured_products(            db: AsyncSession,        *,        limit: int = 5    ) -> List[ProxyProduct]:        """        Получение рекомендуемых продуктов.        Args:            db: Сессия базы данных            limit: Максимальное количество продуктов        Returns:            List[ProxyProduct]: Список рекомендуемых продуктов        """        try:            result = await db.execute(                select(ProxyProduct)                .where(                    and_(                        ProxyProduct.is_active.is_(True),                        ProxyProduct.stock_available > 0,                        ProxyProduct.is_featured.is_(True)                    )                )                .order_by(                    ProxyProduct.farm_efficiency.desc().nulls_last(),                    ProxyProduct.uptime_guarantee.desc().nulls_last(),                    ProxyProduct.speed_mbps.desc().nulls_last()                )                .limit(min(limit, 20))            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting featured products: {e}")            return []    @staticmethod    async def get_products_stats(db: AsyncSession) -> Dict[str, Any]:        """        Получение общей статистики продуктов.        Args:            db: Сессия базы данных        Returns:            Dict[str, Any]: Статистика продуктов        """        try:            # Общее количество активных продуктов            total_result = await db.execute(                select(func.count(ProxyProduct.id))                .where(ProxyProduct.is_active.is_(True))            )            total_products = total_result.scalar() or 0            # Средняя цена            avg_price_result = await db.execute(                select(func.avg(ProxyProduct.price_per_proxy))                .where(ProxyProduct.is_active.is_(True))            )            avg_price = avg_price_result.scalar() or Decimal('0')            # Количество стран            countries_result = await db.execute(                select(func.count(distinct(ProxyProduct.country_code)))                .where(ProxyProduct.is_active.is_(True))            )            countries_count = countries_result.scalar() or 0            # Общий доступный сток            stock_result = await db.execute(                select(func.sum(ProxyProduct.stock_available))                .where(ProxyProduct.is_active.is_(True))            )            total_stock = stock_result.scalar() or 0            # Статистика по категориям            categories_result = await db.execute(                select(                    ProxyProduct.proxy_category,                    func.count(ProxyProduct.id)                )                .where(ProxyProduct.is_active.is_(True))                .group_by(ProxyProduct.proxy_category)            )            categories_stats = {category.value: count for category, count in categories_result.all()}            return {                "total_products": total_products,                "average_price": str(avg_price.quantize(Decimal('0.01'))),                "countries_available": countries_count,                "total_stock": total_stock,                "categories_breakdown": categories_stats            }        except Exception as e:            logger.error(f"Error getting products stats: {e}")            return {                "total_products": 0,                "average_price": "0.00",                "countries_available": 0,                "total_stock": 0,                "categories_breakdown": {}            }    async def update_stock(        self,        db: AsyncSession,        *,        product_id: int,        stock_change: int    ) -> Optional[ProxyProduct]:        """        Обновление остатков продукта.        Args:            db: Сессия базы данных            product_id: ID продукта            stock_change: Изменение остатка (может быть отрицательным)        Returns:            Optional[ProxyProduct]: Обновленный продукт или None        """        try:            product = await self.get(db, obj_id=product_id)            if not product:                logger.warning(f"Product {product_id} not found for stock update")                return None            new_stock = max(0, product.stock_available + stock_change)            product.stock_available = new_stock            await db.commit()            await db.refresh(product)            logger.info(f"Updated stock for product {product_id}: {stock_change} (new stock: {new_stock})")            return product        except Exception as e:            await db.rollback()            logger.error(f"Error updating stock for product {product_id}: {e}")            return Noneproxy_product_crud = CRUDProxyProduct(ProxyProduct)