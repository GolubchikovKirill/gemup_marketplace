"""CRUD операции для корзины покупок.Содержит методы для управления корзиной пользователей и гостей,добавления/удаления товаров и расчета итоговых сумм.Оптимизировано для MVP функций."""import loggingfrom datetime import datetime, timedelta, timezonefrom decimal import Decimalfrom typing import List, Optional, Dict, Anyfrom sqlalchemy import select, and_, delete, or_from sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.orm import selectinloadfrom app.crud.base import CRUDBasefrom app.models.models import ShoppingCart, ProxyProductfrom app.schemas.cart import CartItemCreate, CartItemUpdatelogger = logging.getLogger(__name__)class CRUDShoppingCart(CRUDBase[ShoppingCart, CartItemCreate, CartItemUpdate]):    """    CRUD для управления корзиной покупок.    Поддерживает как зарегистрированных пользователей, так и гостей.    Обеспечивает добавление товаров, расчет сумм и валидацию.    """    async def get_user_cart(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> List[ShoppingCart]:        """        Получение корзины пользователя или гостя - КЛЮЧЕВОЕ для MVP.        Args:            db: Сессия базы данных            user_id: ID пользователя (для зарегистрированных)            session_id: ID сессии (для гостей)        Returns:            List[ShoppingCart]: Элементы корзины        """        try:            if user_id:                # Корзина зарегистрированного пользователя                result = await db.execute(                    select(ShoppingCart)                    .options(selectinload(ShoppingCart.proxy_product))                    .where(ShoppingCart.user_id == user_id)                    .order_by(ShoppingCart.created_at.desc())                )            elif session_id:                # Корзина гостя                current_time = datetime.now(timezone.utc)                result = await db.execute(                    select(ShoppingCart)                    .options(selectinload(ShoppingCart.proxy_product))                    .where(                        and_(                            ShoppingCart.guest_session_id == session_id,                            or_(                                ShoppingCart.expires_at.is_(None),                                ShoppingCart.expires_at > current_time                            )                        )                    )                    .order_by(ShoppingCart.created_at.desc())                )            else:                return []            cart_items = list(result.scalars().all())            logger.debug(f"Found {len(cart_items)} items in cart")            return cart_items        except Exception as e:            logger.error(f"Error getting cart: {e}")            return []    async def add_item_to_cart(        self,        db: AsyncSession,        *,        product_id: int,        quantity: int,        user_id: Optional[int] = None,        session_id: Optional[str] = None,        generation_params: Optional[str] = None    ) -> Optional[ShoppingCart]:        """        Добавление товара в корзину - КЛЮЧЕВОЕ для MVP.        Args:            db: Сессия базы данных            product_id: ID продукта            quantity: Количество            user_id: ID пользователя (опционально)            session_id: ID сессии (опционально)            generation_params: Параметры генерации        Returns:            Optional[ShoppingCart]: Добавленный элемент или None        """        try:            if not user_id and not session_id:                raise ValueError("Either user_id or session_id must be provided")            # Проверяем существование продукта            product = await db.get(ProxyProduct, product_id)            if not product or not product.is_active:                raise ValueError("Product not found or inactive")            # Проверяем количество            if quantity < product.min_quantity or quantity > product.max_quantity:                raise ValueError(f"Quantity must be between {product.min_quantity} and {product.max_quantity}")            if quantity > product.stock_available:                raise ValueError(f"Only {product.stock_available} items available")            # Проверяем, есть ли уже такой товар в корзине            existing_item = None            if user_id:                result = await db.execute(                    select(ShoppingCart).where(                        and_(                            ShoppingCart.user_id == user_id,                            ShoppingCart.proxy_product_id == product_id                        )                    )                )                existing_item = result.scalar_one_or_none()            elif session_id:                result = await db.execute(                    select(ShoppingCart).where(                        and_(                            ShoppingCart.guest_session_id == session_id,                            ShoppingCart.proxy_product_id == product_id                        )                    )                )                existing_item = result.scalar_one_or_none()            if existing_item:                # Обновляем количество                new_quantity = existing_item.quantity + quantity                if new_quantity > product.max_quantity:                    raise ValueError(f"Total quantity cannot exceed {product.max_quantity}")                existing_item.quantity = new_quantity                existing_item.generation_params = generation_params                existing_item.updated_at = datetime.now(timezone.utc)                await db.commit()                await db.refresh(existing_item)                return existing_item            else:                # Создаем новый элемент                expires_at = None                if session_id:                    expires_at = datetime.now(timezone.utc) + timedelta(days=7)                cart_item = ShoppingCart(                    user_id=user_id,                    guest_session_id=session_id,                    proxy_product_id=product_id,                    quantity=quantity,                    generation_params=generation_params,                    expires_at=expires_at,                    created_at=datetime.now(timezone.utc),                    updated_at=datetime.now(timezone.utc)                )                db.add(cart_item)                await db.commit()                await db.refresh(cart_item)                logger.info(f"Added item to cart: product {product_id}, quantity {quantity}")                return cart_item        except ValueError:            await db.rollback()            raise        except Exception as e:            await db.rollback()            logger.error(f"Error adding item to cart: {e}")            return None    async def update_cart_item_quantity(        self,        db: AsyncSession,        *,        item_id: int,        new_quantity: int,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> Optional[ShoppingCart]:        """        Обновление количества товара в корзине.        Args:            db: Сессия базы данных            item_id: ID элемента корзины            new_quantity: Новое количество            user_id: ID пользователя (для проверки прав)            session_id: ID сессии (для проверки прав)        Returns:            Optional[ShoppingCart]: Обновленный элемент или None        """        try:            # Получаем элемент корзины            query = select(ShoppingCart).options(selectinload(ShoppingCart.proxy_product)).where(ShoppingCart.id == item_id)            if user_id:                query = query.where(ShoppingCart.user_id == user_id)            elif session_id:                query = query.where(ShoppingCart.guest_session_id == session_id)            else:                raise ValueError("Either user_id or session_id must be provided")            result = await db.execute(query)            cart_item = result.scalar_one_or_none()            if not cart_item:                raise ValueError("Cart item not found")            product = cart_item.proxy_product            if not product or not product.is_active:                raise ValueError("Product not found or inactive")            # Проверяем новое количество            if new_quantity < product.min_quantity or new_quantity > product.max_quantity:                raise ValueError(f"Quantity must be between {product.min_quantity} and {product.max_quantity}")            if new_quantity > product.stock_available:                raise ValueError(f"Only {product.stock_available} items available")            # Обновляем количество            cart_item.quantity = new_quantity            cart_item.updated_at = datetime.now(timezone.utc)            await db.commit()            await db.refresh(cart_item)            logger.info(f"Updated cart item {item_id} quantity to {new_quantity}")            return cart_item        except ValueError:            await db.rollback()            raise        except Exception as e:            await db.rollback()            logger.error(f"Error updating cart item quantity: {e}")            return None    async def remove_cart_item(        self,        db: AsyncSession,        *,        item_id: int,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> bool:        """        Удаление товара из корзины.        Args:            db: Сессия базы данных            item_id: ID элемента корзины            user_id: ID пользователя (для проверки прав)            session_id: ID сессии (для проверки прав)        Returns:            bool: Успешность удаления        """        try:            query = delete(ShoppingCart).where(ShoppingCart.id == item_id)            if user_id:                query = query.where(ShoppingCart.user_id == user_id)            elif session_id:                query = query.where(ShoppingCart.guest_session_id == session_id)            else:                raise ValueError("Either user_id or session_id must be provided")            result = await db.execute(query)            await db.commit()            success = result.rowcount > 0            if success:                logger.info(f"Removed cart item {item_id}")            return success        except ValueError:            await db.rollback()            raise        except Exception as e:            await db.rollback()            logger.error(f"Error removing cart item: {e}")            return False    async def clear_cart(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> bool:        """        Очистка корзины - КЛЮЧЕВОЕ для оформления заказа.        Args:            db: Сессия базы данных            user_id: ID пользователя            session_id: ID сессии        Returns:            bool: Успешность очистки        """        try:            if user_id:                result = await db.execute(                    delete(ShoppingCart).where(ShoppingCart.user_id == user_id)                )            elif session_id:                result = await db.execute(                    delete(ShoppingCart).where(ShoppingCart.guest_session_id == session_id)                )            else:                raise ValueError("Either user_id or session_id must be provided")            await db.commit()            count = result.rowcount or 0            logger.info(f"Cleared {count} items from cart")            return True        except ValueError:            await db.rollback()            raise        except Exception as e:            await db.rollback()            logger.error(f"Error clearing cart: {e}")            return False    async def calculate_cart_total(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> Dict[str, Any]:        """        Расчет итоговой суммы корзины - КЛЮЧЕВОЕ для оформления заказа.        Args:            db: Сессия базы данных            user_id: ID пользователя            session_id: ID сессии        Returns:            Dict[str, Any]: Детали расчета        """        try:            cart_items = await self.get_user_cart(db, user_id=user_id, session_id=session_id)            if not cart_items:                return {                    "total_items": 0,                    "total_amount": "0.00000000",                    "currency": "USD",                    "items": []                }            total_amount = Decimal('0.00000000')            total_items = 0            items_details = []            for item in cart_items:                if item.proxy_product and item.proxy_product.is_active:                    item_total = item.proxy_product.price_per_proxy * item.quantity                    total_amount += item_total                    total_items += item.quantity                    items_details.append({                        "item_id": item.id,                        "product_id": item.proxy_product_id,                        "product_name": item.proxy_product.name,                        "quantity": item.quantity,                        "unit_price": str(item.proxy_product.price_per_proxy),                        "total_price": str(item_total)                    })            return {                "total_items": total_items,                "total_amount": str(total_amount),                "currency": "USD",                "items": items_details            }        except Exception as e:            logger.error(f"Error calculating cart total: {e}")            return {                "total_items": 0,                "total_amount": "0.00000000",                "currency": "USD",                "items": []            }    async def validate_cart_before_checkout(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> Dict[str, Any]:        """        Валидация корзины перед оформлением заказа.        Args:            db: Сессия базы данных            user_id: ID пользователя            session_id: ID сессии        Returns:            Dict[str, Any]: Результат валидации        """        try:            cart_items = await self.get_user_cart(db, user_id=user_id, session_id=session_id)            if not cart_items:                return {                    "is_valid": False,                    "errors": ["Cart is empty"],                    "warnings": []                }            errors = []            warnings = []            valid_items = 0            for item in cart_items:                if not item.proxy_product:                    errors.append(f"Product not found for cart item {item.id}")                    continue                product = item.proxy_product                if not product.is_active:                    errors.append(f"Product '{product.name}' is no longer available")                    continue                if item.quantity < product.min_quantity:                    errors.append(f"Minimum quantity for '{product.name}' is {product.min_quantity}")                    continue                if item.quantity > product.max_quantity:                    errors.append(f"Maximum quantity for '{product.name}' is {product.max_quantity}")                    continue                if item.quantity > product.stock_available:                    errors.append(f"Only {product.stock_available} items available for '{product.name}'")                    continue                valid_items += 1            is_valid = len(errors) == 0 and valid_items > 0            return {                "is_valid": is_valid,                "errors": errors,                "warnings": warnings,                "valid_items": valid_items,                "total_items": len(cart_items)            }        except Exception as e:            logger.error(f"Error validating cart: {e}")            return {                "is_valid": False,                "errors": [f"Validation failed: {str(e)}"],                "warnings": []            }    async def get_cart_summary(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> Dict[str, Any]:        """        Получение краткой сводки корзины.        Args:            db: Сессия базы данных            user_id: ID пользователя            session_id: ID сессии        Returns:            Dict[str, Any]: Сводка корзины        """        try:            cart_total = await self.calculate_cart_total(db, user_id=user_id, session_id=session_id)            return {                "items_count": len(cart_total["items"]),                "total_quantity": cart_total["total_items"],                "total_amount": cart_total["total_amount"],                "currency": cart_total["currency"],                "last_updated": datetime.now(timezone.utc).isoformat(),                "user_type": "registered" if user_id else "guest",                "has_unavailable_items": False  # Можно расширить логику            }        except Exception as e:            logger.error(f"Error getting cart summary: {e}")            return {                "items_count": 0,                "total_quantity": 0,                "total_amount": "0.00000000",                "currency": "USD",                "last_updated": datetime.now(timezone.utc).isoformat(),                "user_type": "guest",                "has_unavailable_items": False            }    async def check_cart_item_changes(        self,        db: AsyncSession,        *,        user_id: Optional[int] = None,        session_id: Optional[str] = None    ) -> Dict[str, Any]:        """        Проверка изменений в товарах корзины.        Args:            db: Сессия базы данных            user_id: ID пользователя            session_id: ID сессии        Returns:            Dict[str, Any]: Информация об изменениях        """        try:            cart_items = await self.get_user_cart(db, user_id=user_id, session_id=session_id)            price_changes = []            availability_changes = []            stock_changes = []            for item in cart_items:                if not item.proxy_product:                    availability_changes.append({                        "item_id": item.id,                        "product_id": item.proxy_product_id,                        "change": "Product no longer exists"                    })                    continue                product = item.proxy_product                if not product.is_active:                    availability_changes.append({                        "item_id": item.id,                        "product_id": product.id,                        "product_name": product.name,                        "change": "Product is no longer available"                    })                if item.quantity > product.stock_available:                    stock_changes.append({                        "item_id": item.id,                        "product_id": product.id,                        "product_name": product.name,                        "requested_quantity": item.quantity,                        "available_quantity": product.stock_available,                        "change": f"Stock reduced to {product.stock_available}"                    })            return {                "price_changes": price_changes,                "availability_changes": availability_changes,                "stock_changes": stock_changes,                "total_changes": len(price_changes) + len(availability_changes) + len(stock_changes)            }        except Exception as e:            logger.error(f"Error checking cart changes: {e}")            return {                "price_changes": [],                "availability_changes": [],                "stock_changes": [],                "total_changes": 0            }    async def cleanup_expired_guest_carts(self, db: AsyncSession) -> int:        """        Очистка просроченных гостевых корзин.        Args:            db: Сессия базы данных        Returns:            int: Количество удаленных элементов        """        try:            current_time = datetime.now(timezone.utc)            result = await db.execute(                delete(ShoppingCart).where(                    and_(                        ShoppingCart.guest_session_id.is_not(None),                        ShoppingCart.expires_at < current_time                    )                )            )            await db.commit()            count = result.rowcount or 0            if count > 0:                logger.info(f"Cleaned up {count} expired guest cart items")            return count        except Exception as e:            await db.rollback()            logger.error(f"Error cleaning up expired carts: {e}")            return 0shopping_cart_crud = CRUDShoppingCart(ShoppingCart)