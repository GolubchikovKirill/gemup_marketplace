"""CRUD операции для корзины покупок.Содержит методы для управления корзиной как зарегистрированных пользователей,так и гостевых сессий. Поддерживает добавление, обновление и очистку корзины."""import loggingfrom datetime import datetime, timedeltafrom typing import List, Optional, Dict, Anyfrom decimal import Decimalfrom sqlalchemy import select, delete, and_, funcfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy.orm import selectinloadfrom app.crud.base import CRUDBasefrom app.models.models import ShoppingCart, ProxyProductfrom app.schemas.cart import CartItemCreate, CartItemUpdatelogger = logging.getLogger(__name__)class CRUDShoppingCart(CRUDBase[ShoppingCart, CartItemCreate, CartItemUpdate]):    """    CRUD для управления корзиной покупок.    Поддерживает работу с корзиной как для зарегистрированных пользователей    (по user_id), так и для гостевых сессий (по session_id).    """    @staticmethod    async def get_user_cart(            db: AsyncSession,            *,            user_id: int    ) -> List[ShoppingCart]:        """        Получение корзины зарегистрированного пользователя.        Args:            db: Сессия базы данных            user_id: ID пользователя        Returns:            List[ShoppingCart]: Элементы корзины пользователя        """        try:            result = await db.execute(                select(ShoppingCart)                .options(selectinload(ShoppingCart.proxy_product))                .where(ShoppingCart.user_id == user_id)                .order_by(ShoppingCart.created_at.desc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting cart for user {user_id}: {e}")            return []    async def get_guest_cart(            self,            db: AsyncSession,            *,            session_id: str    ) -> List[ShoppingCart]:        """        Получение корзины гостевого пользователя.        Args:            db: Сессия базы данных            session_id: ID гостевой сессии        Returns:            List[ShoppingCart]: Элементы корзины гостя        """        try:            # Проверяем срок действия гостевых элементов корзины            await self._cleanup_expired_guest_items(db, session_id)            result = await db.execute(                select(ShoppingCart)                .options(selectinload(ShoppingCart.proxy_product))                .where(ShoppingCart.session_id == session_id)                .order_by(ShoppingCart.created_at.desc())            )            return list(result.scalars().all())        except Exception as e:            logger.error(f"Error getting guest cart for session {session_id}: {e}")            return []    @staticmethod    async def add_to_cart(            db: AsyncSession,            *,            user_id: Optional[int] = None,            session_id: Optional[str] = None,            proxy_product_id: int,            quantity: int = 1,            generation_params: Optional[str] = None    ) -> Optional[ShoppingCart]:        """        Добавление товара в корзину.        Args:            db: Сессия базы данных            user_id: ID пользователя (для зарегистрированных)            session_id: ID сессии (для гостей)            proxy_product_id: ID продукта прокси            quantity: Количество            generation_params: Параметры генерации (JSON)        Returns:            Optional[ShoppingCart]: Элемент корзины или None        """        try:            # Валидация входных данных            if not user_id and not session_id:                logger.error("Either user_id or session_id must be provided")                return None            if quantity <= 0:                logger.warning(f"Invalid quantity: {quantity}")                return None            # Проверяем существование продукта            product = await db.get(ProxyProduct, proxy_product_id)            if not product:                logger.warning(f"Product {proxy_product_id} not found")                return None            if not product.is_active:                logger.warning(f"Product {proxy_product_id} is not active")                return None            # Проверяем наличие на складе            if product.stock_available < quantity:                logger.warning(                    f"Insufficient stock for product {proxy_product_id}: {product.stock_available} < {quantity}")                return None            # Проверяем, есть ли уже такой товар в корзине            existing_query = select(ShoppingCart).where(                ShoppingCart.proxy_product_id == proxy_product_id            )            if user_id:                existing_query = existing_query.where(ShoppingCart.user_id == user_id)            else:                existing_query = existing_query.where(ShoppingCart.session_id == session_id)            result = await db.execute(existing_query)            existing_item = result.scalar_one_or_none()            if existing_item:                # Обновляем количество существующего элемента                new_quantity = existing_item.quantity + quantity                # Проверяем лимиты продукта                if new_quantity > product.max_quantity:                    logger.warning(                        f"Quantity {new_quantity} exceeds max {product.max_quantity} for product {proxy_product_id}")                    return None                existing_item.quantity = new_quantity                existing_item.updated_at = datetime.now()                if generation_params:                    existing_item.generation_params = generation_params                await db.commit()                await db.refresh(existing_item)                logger.info(f"Updated cart item {existing_item.id} quantity to {new_quantity}")                return existing_item            else:                # Создаем новый элемент корзины                expires_at = None                if session_id:  # Для гостей устанавливаем срок действия                    expires_at = datetime.now() + timedelta(hours=24)                cart_item = ShoppingCart(                    user_id=user_id,                    session_id=session_id,                    proxy_product_id=proxy_product_id,                    quantity=quantity,                    generation_params=generation_params,                    expires_at=expires_at                )                db.add(cart_item)                await db.commit()                await db.refresh(cart_item)                logger.info(f"Added new cart item {cart_item.id}")                return cart_item        except Exception as e:            await db.rollback()            logger.error(f"Error adding to cart: {e}")            return None    @staticmethod    async def update_cart_item_quantity(            db: AsyncSession,            *,            cart_item_id: int,            user_id: Optional[int] = None,            session_id: Optional[str] = None,            new_quantity: int    ) -> Optional[ShoppingCart]:        """        Обновление количества элемента корзины.        Args:            db: Сессия базы данных            cart_item_id: ID элемента корзины            user_id: ID пользователя (для проверки владения)            session_id: ID сессии (для проверки владения)            new_quantity: Новое количество        Returns:            Optional[ShoppingCart]: Обновленный элемент или None        """        try:            if new_quantity <= 0:                logger.warning(f"Invalid quantity: {new_quantity}")                return None            # Получаем элемент корзины с проверкой владения            query = select(ShoppingCart).where(ShoppingCart.id == cart_item_id)            if user_id:                query = query.where(ShoppingCart.user_id == user_id)            elif session_id:                query = query.where(ShoppingCart.session_id == session_id)            else:                logger.error("Either user_id or session_id must be provided")                return None            result = await db.execute(query)            cart_item = result.scalar_one_or_none()            if not cart_item:                logger.warning(f"Cart item {cart_item_id} not found or access denied")                return None            # Проверяем лимиты продукта            product = await db.get(ProxyProduct, cart_item.proxy_product_id)            if product and new_quantity > product.max_quantity:                logger.warning(f"Quantity {new_quantity} exceeds max {product.max_quantity}")                return None            if product and new_quantity > product.stock_available:                logger.warning(f"Quantity {new_quantity} exceeds available stock {product.stock_available}")                return None            cart_item.quantity = new_quantity            cart_item.updated_at = datetime.now()            await db.commit()            await db.refresh(cart_item)            logger.info(f"Updated cart item {cart_item_id} quantity to {new_quantity}")            return cart_item        except Exception as e:            await db.rollback()            logger.error(f"Error updating cart item quantity: {e}")            return None    @staticmethod    async def remove_cart_item(            db: AsyncSession,            *,            cart_item_id: int,            user_id: Optional[int] = None,            session_id: Optional[str] = None    ) -> bool:        """        Удаление элемента из корзины.        Args:            db: Сессия базы данных            cart_item_id: ID элемента корзины            user_id: ID пользователя (для проверки владения)            session_id: ID сессии (для проверки владения)        Returns:            bool: True если элемент удален успешно        """        try:            query = select(ShoppingCart).where(ShoppingCart.id == cart_item_id)            if user_id:                query = query.where(ShoppingCart.user_id == user_id)            elif session_id:                query = query.where(ShoppingCart.session_id == session_id)            else:                logger.error("Either user_id or session_id must be provided")                return False            result = await db.execute(query)            cart_item = result.scalar_one_or_none()            if not cart_item:                logger.warning(f"Cart item {cart_item_id} not found or access denied")                return False            await db.delete(cart_item)            await db.commit()            logger.info(f"Removed cart item {cart_item_id}")            return True        except Exception as e:            await db.rollback()            logger.error(f"Error removing cart item {cart_item_id}: {e}")            return False    @staticmethod    async def clear_user_cart(            db: AsyncSession,            *,            user_id: int    ) -> bool:        """        Очистка корзины зарегистрированного пользователя.        Args:            db: Сессия базы данных            user_id: ID пользователя        Returns:            bool: True если корзина очищена успешно        """        try:            result = await db.execute(                delete(ShoppingCart).where(ShoppingCart.user_id == user_id)            )            await db.commit()            deleted_count = result.rowcount            logger.info(f"Cleared {deleted_count} items from user {user_id} cart")            return True        except Exception as e:            await db.rollback()            logger.error(f"Error clearing cart for user {user_id}: {e}")            return False    @staticmethod    async def clear_guest_cart(            db: AsyncSession,            *,            session_id: str    ) -> bool:        """        Очистка корзины гостевого пользователя.        Args:            db: Сессия базы данных            session_id: ID гостевой сессии        Returns:            bool: True если корзина очищена успешно        """        try:            result = await db.execute(                delete(ShoppingCart).where(ShoppingCart.session_id == session_id)            )            await db.commit()            deleted_count = result.rowcount            logger.info(f"Cleared {deleted_count} items from guest session {session_id}")            return True        except Exception as e:            await db.rollback()            logger.error(f"Error clearing guest cart for session {session_id}: {e}")            return False    @staticmethod    async def calculate_cart_total(            db: AsyncSession,            *,            cart_items: List[ShoppingCart]    ) -> Dict[str, Any]:        """        Расчет общей стоимости корзины.        Args:            db: Сессия базы данных            cart_items: Элементы корзины        Returns:            Dict[str, Any]: Информация о стоимости корзины        """        try:            total_amount = Decimal('0.00')            total_items = 0            items_breakdown = []            for item in cart_items:                # Загружаем продукт если не загружен                if not item.proxy_product:                    product = await db.get(ProxyProduct, item.proxy_product_id)                else:                    product = item.proxy_product                if product and product.is_active:                    item_total = product.price_per_proxy * item.quantity                    total_amount += item_total                    total_items += item.quantity                    items_breakdown.append({                        "cart_item_id": item.id,                        "product_id": product.id,                        "product_name": product.name,                        "unit_price": str(product.price_per_proxy),                        "quantity": item.quantity,                        "total_price": str(item_total)                    })            return {                "total_amount": str(total_amount),                "total_items": total_items,                "items_count": len(items_breakdown),                "items_breakdown": items_breakdown            }        except Exception as e:            logger.error(f"Error calculating cart total: {e}")            return {                "total_amount": "0.00",                "total_items": 0,                "items_count": 0,                "items_breakdown": []            }    async def merge_guest_cart_to_user(            self,            db: AsyncSession,            *,            session_id: str,            user_id: int    ) -> bool:        """        Объединение гостевой корзины с корзиной пользователя.        Args:            db: Сессия базы данных            session_id: ID гостевой сессии            user_id: ID пользователя        Returns:            bool: True если объединение прошло успешно        """        try:            # Получаем элементы гостевой корзины            guest_items = await self.get_guest_cart(db, session_id=session_id)            if not guest_items:                return True            # Получаем элементы корзины пользователя            user_items = await self.get_user_cart(db, user_id=user_id)            user_products = {item.proxy_product_id: item for item in user_items}            merged_count = 0            for guest_item in guest_items:                if guest_item.proxy_product_id in user_products:                    # Обновляем количество существующего элемента                    user_item = user_products[guest_item.proxy_product_id]                    user_item.quantity += guest_item.quantity                    user_item.updated_at = datetime.now()                    merged_count += 1                else:                    # Переносим элемент в корзину пользователя                    guest_item.user_id = user_id                    guest_item.session_id = None                    guest_item.expires_at = None                    guest_item.updated_at = datetime.now()                    merged_count += 1            # Удаляем оставшиеся гостевые элементы            await self.clear_guest_cart(db, session_id=session_id)            await db.commit()            logger.info(f"Merged {merged_count} guest cart items to user {user_id}")            return True        except Exception as e:            await db.rollback()            logger.error(f"Error merging guest cart to user {user_id}: {e}")            return False    @staticmethod    async def _cleanup_expired_guest_items(            db: AsyncSession,            session_id: Optional[str] = None    ) -> int:        """        Очистка просроченных элементов гостевой корзины.        Args:            db: Сессия базы данных            session_id: ID конкретной сессии (опционально)        Returns:            int: Количество удаленных элементов        """        try:            current_time = datetime.now()            query = delete(ShoppingCart).where(                and_(                    ShoppingCart.session_id.isnot(None),                    ShoppingCart.expires_at.isnot(None),                    ShoppingCart.expires_at < current_time                )            )            if session_id:                query = query.where(ShoppingCart.session_id == session_id)            result = await db.execute(query)            await db.commit()            deleted_count = result.rowcount            if deleted_count > 0:                logger.info(f"Cleaned up {deleted_count} expired guest cart items")            return deleted_count        except Exception as e:            await db.rollback()            logger.error(f"Error cleaning up expired guest cart items: {e}")            return 0    @staticmethod    async def get_cart_stats(            db: AsyncSession,            *,            days: int = 30    ) -> Dict[str, Any]:        """        Получение статистики по корзинам.        Args:            db: Сессия базы данных            days: Период для статистики в днях        Returns:            Dict[str, Any]: Статистика корзин        """        try:            start_date = datetime.now() - timedelta(days=days)            # Общее количество активных корзин            total_carts_result = await db.execute(                select(func.count(func.distinct(                    func.coalesce(ShoppingCart.user_id, ShoppingCart.session_id)                )))                .where(ShoppingCart.created_at >= start_date)            )            total_carts = total_carts_result.scalar() or 0            # Общее количество элементов            total_items_result = await db.execute(                select(func.count(ShoppingCart.id))                .where(ShoppingCart.created_at >= start_date)            )            total_items = total_items_result.scalar() or 0            # Зарегистрированные vs гостевые            user_carts_result = await db.execute(                select(func.count(func.distinct(ShoppingCart.user_id)))                .where(                    and_(                        ShoppingCart.user_id.isnot(None),                        ShoppingCart.created_at >= start_date                    )                )            )            user_carts = user_carts_result.scalar() or 0            guest_carts = total_carts - user_carts            return {                "total_active_carts": total_carts,                "total_items": total_items,                "user_carts": user_carts,                "guest_carts": guest_carts,                "average_items_per_cart": round(total_items / max(total_carts, 1), 2),                "period_days": days            }        except Exception as e:            logger.error(f"Error getting cart stats: {e}")            return {                "total_active_carts": 0,                "total_items": 0,                "user_carts": 0,                "guest_carts": 0,                "average_items_per_cart": 0,                "period_days": days            }shopping_cart_crud = CRUDShoppingCart(ShoppingCart)