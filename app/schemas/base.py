"""Базовые схемы для приложения.Содержит общие схемы, используемые в различных частях приложения,включая базовые ответы, пагинацию и сообщения."""from datetime import datetimefrom typing import Optional, List, Generic, TypeVarfrom pydantic import BaseModel, ConfigDict, Field, field_validator, field_serializer# Типизация для Generic схемT = TypeVar('T')class BaseResponse(BaseModel):    """    Базовая схема ответа.    Содержит общие поля для всех объектов с временными метками.    """    model_config = ConfigDict(from_attributes=True)    id: int = Field(..., description="Уникальный идентификатор")    created_at: datetime = Field(..., description="Дата создания")    updated_at: datetime = Field(..., description="Дата последнего обновления")    @field_serializer('created_at', 'updated_at')    def serialize_datetime(self, value: datetime) -> str:        """Сериализация datetime в ISO формат."""        return value.isoformat()class PaginationParams(BaseModel):    """    Параметры пагинации.    Используется для запросов с постраничной навигацией.    """    skip: int = Field(0, ge=0, le=10000, description="Количество пропускаемых записей")    limit: int = Field(20, ge=1, le=100, description="Максимальное количество записей на странице")    @field_validator('skip')    @classmethod    def validate_skip(cls, v: int) -> int:        """Валидация параметра skip."""        if v < 0:            raise ValueError('Skip parameter cannot be negative')        return v    @field_validator('limit')    @classmethod    def validate_limit(cls, v: int) -> int:        """Валидация параметра limit."""        if v < 1:            raise ValueError('Limit must be at least 1')        if v > 100:            raise ValueError('Limit cannot exceed 100')        return v    @property    def page(self) -> int:        """Вычисляет номер текущей страницы."""        return (self.skip // self.limit) + 1    @property    def offset(self) -> int:        """Алиас для skip (совместимость с SQLAlchemy)."""        return self.skipclass PaginatedResponse(BaseModel, Generic[T]):    """    Generic схема для постраничных ответов.    Содержит список элементов и метаданные пагинации.    """    items: List[T] = Field(..., description="Список элементов")    total: int = Field(..., ge=0, description="Общее количество элементов")    page: int = Field(..., ge=1, description="Текущая страница")    size: int = Field(..., ge=1, description="Размер страницы")    pages: int = Field(..., ge=1, description="Общее количество страниц")    # Дополнительные метаданные    has_next: bool = Field(..., description="Есть ли следующая страница")    has_prev: bool = Field(..., description="Есть ли предыдущая страница")    next_page: Optional[int] = Field(None, description="Номер следующей страницы")    prev_page: Optional[int] = Field(None, description="Номер предыдущей страницы")    def __init__(self, **data):        super().__init__(**data)        # Вычисляем метаданные навигации        self.has_next = self.page < self.pages        self.has_prev = self.page > 1        self.next_page = self.page + 1 if self.has_next else None        self.prev_page = self.page - 1 if self.has_prev else Noneclass MessageResponse(BaseModel):    """    Схема для простых сообщений.    Используется для ответов, содержащих только текстовое сообщение.    """    message: str = Field(..., min_length=1, description="Текст сообщения")    success: bool = Field(True, description="Успешность операции")    code: Optional[str] = Field(None, description="Код ответа для программной обработки")    details: Optional[dict] = Field(None, description="Дополнительные детали")    @field_validator('message')    @classmethod    def validate_message(cls, v: str) -> str:        """Валидация сообщения."""        if not v.strip():            raise ValueError('Message cannot be empty')        return v.strip()class ErrorResponse(BaseModel):    """    Схема для ошибок.    Стандартизированный формат ошибок API.    """    error: str = Field(..., description="Описание ошибки")    error_code: str = Field(..., description="Код ошибки")    details: Optional[dict] = Field(None, description="Дополнительные детали ошибки")    timestamp: datetime = Field(default_factory=datetime.now, description="Время возникновения ошибки")    request_id: Optional[str] = Field(None, description="Идентификатор запроса для отладки")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class ValidationErrorResponse(BaseModel):    """    Схема для ошибок валидации.    Расширенная информация об ошибках валидации полей.    """    error: str = Field("Validation Error", description="Тип ошибки")    error_code: str = Field("VALIDATION_ERROR", description="Код ошибки")    fields: List[dict] = Field(..., description="Список полей с ошибками")    timestamp: datetime = Field(default_factory=datetime.now, description="Время ошибки")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class HealthCheckResponse(BaseModel):    """    Схема ответа проверки здоровья системы.    """    status: str = Field(..., description="Статус системы (healthy/unhealthy)")    timestamp: datetime = Field(default_factory=datetime.now, description="Время проверки")    version: str = Field(..., description="Версия приложения")    uptime_seconds: int = Field(..., ge=0, description="Время работы в секундах")    # Статус компонентов    database: str = Field(..., description="Статус базы данных")    redis: str = Field(..., description="Статус Redis")    external_apis: dict = Field(default_factory=dict, description="Статус внешних API")    # Метрики    memory_usage_mb: Optional[float] = Field(None, description="Использование памяти в МБ")    cpu_usage_percent: Optional[float] = Field(None, description="Использование CPU в %")    active_connections: Optional[int] = Field(None, description="Количество активных соединений")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class SearchParams(BaseModel):    """    Параметры поиска.    Базовые параметры для поисковых запросов.    """    query: Optional[str] = Field(None, max_length=200, description="Поисковый запрос")    sort_by: Optional[str] = Field("created_at", description="Поле для сортировки")    sort_order: str = Field("desc", pattern="^(asc|desc)$", description="Направление сортировки")    filters: Optional[dict] = Field(None, description="Дополнительные фильтры")    @field_validator('query')    @classmethod    def validate_query(cls, v: Optional[str]) -> Optional[str]:        """Валидация поискового запроса."""        if v is not None:            v = v.strip()            if len(v) < 2:                raise ValueError('Search query must be at least 2 characters long')            return v        return v    @field_validator('sort_by')    @classmethod    def validate_sort_by(cls, v: Optional[str]) -> Optional[str]:        """Валидация поля сортировки."""        if v is not None:            # Базовая проверка названия поля            allowed_fields = [                'id', 'created_at', 'updated_at', 'name', 'price',                'status', 'amount', 'date', 'title'            ]            if v not in allowed_fields:                raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')        return vclass BulkOperationRequest(BaseModel):    """    Запрос массовой операции.    Используется для выполнения операций над множеством объектов.    """    ids: List[int] = Field(..., min_items=1, max_items=100, description="Список ID объектов")    operation: str = Field(..., description="Тип операции")    parameters: Optional[dict] = Field(None, description="Параметры операции")    @field_validator('ids')    @classmethod    def validate_ids(cls, v: List[int]) -> List[int]:        """Валидация списка ID."""        # Убираем дубликаты        unique_ids = list(set(v))        if len(unique_ids) != len(v):            raise ValueError('Duplicate IDs are not allowed')        # Проверяем что все ID положительные        if any(id_val <= 0 for id_val in unique_ids):            raise ValueError('All IDs must be positive')        return unique_idsclass BulkOperationResponse(BaseModel):    """    Ответ массовой операции.    """    total_processed: int = Field(..., ge=0, description="Общее количество обработанных")    successful: int = Field(..., ge=0, description="Успешно обработано")    failed: int = Field(..., ge=0, description="Не удалось обработать")    errors: List[dict] = Field(default_factory=list, description="Список ошибок")    results: List[dict] = Field(default_factory=list, description="Результаты операций")    def __init__(self, **data):        super().__init__(**data)        # Проверяем корректность данных        if self.successful + self.failed != self.total_processed:            raise ValueError('Sum of successful and failed must equal total_processed')class ApiVersionResponse(BaseModel):    """    Информация о версии API.    """    version: str = Field(..., description="Версия API")    build: str = Field(..., description="Номер сборки")    build_date: datetime = Field(..., description="Дата сборки")    environment: str = Field(..., description="Окружение")    features: List[str] = Field(default_factory=list, description="Доступные функции")    deprecations: List[dict] = Field(default_factory=list, description="Устаревшие API")    @field_serializer('build_date')    def serialize_build_date(self, value: datetime) -> str:        return value.isoformat()