"""Базовые схемы для приложения.Содержит общие схемы, используемые в различных частях приложения,включая базовые ответы, пагинацию и сообщения."""from datetime import datetime, timezonefrom typing import Optional, List, Generic, TypeVar, Any, Dictfrom pydantic import BaseModel, ConfigDict, Field, field_validator, field_serializer# Типизация для Generic схемT = TypeVar('T')class BaseResponse(BaseModel):    """    Базовая схема ответа.    Содержит общие поля для всех объектов с временными метками.    """    model_config = ConfigDict(from_attributes=True)    id: int = Field(..., description="Уникальный идентификатор")    created_at: datetime = Field(..., description="Дата создания")    updated_at: datetime = Field(..., description="Дата последнего обновления")    @field_serializer('created_at', 'updated_at')    def serialize_datetime(self, value: datetime) -> str:        """Сериализация datetime в ISO формат."""        return value.isoformat()class PaginationParams(BaseModel):    """    Параметры пагинации.    Используется для запросов с постраничной навигацией.    """    page: int = Field(1, ge=1, le=1000, description="Номер страницы")    per_page: int = Field(20, ge=1, le=100, description="Количество записей на странице")    @field_validator('page')    @classmethod    def validate_page(cls, v: int) -> int:        """Валидация номера страницы."""        if v < 1:            raise ValueError('Page number must be at least 1')        return v    @field_validator('per_page')    @classmethod    def validate_per_page(cls, v: int) -> int:        """Валидация размера страницы."""        if v < 1:            raise ValueError('Per page must be at least 1')        if v > 100:            raise ValueError('Per page cannot exceed 100')        return v    @property    def skip(self) -> int:        """Вычисляет количество записей для пропуска (offset)."""        return (self.page - 1) * self.per_page    @property    def limit(self) -> int:        """Алиас для per_page (совместимость с SQLAlchemy)."""        return self.per_pageclass PaginatedResponse(BaseModel, Generic[T]):    """    Generic схема для постраничных ответов.    Содержит список элементов и метаданные пагинации.    """    items: List[T] = Field(..., description="Список элементов")    total: int = Field(..., ge=0, description="Общее количество элементов")    page: int = Field(..., ge=1, description="Текущая страница")    per_page: int = Field(..., ge=1, description="Размер страницы")    pages: int = Field(..., ge=0, description="Общее количество страниц")    # Дополнительные метаданные    has_next: bool = Field(..., description="Есть ли следующая страница")    has_prev: bool = Field(..., description="Есть ли предыдущая страница")    next_page: Optional[int] = Field(None, description="Номер следующей страницы")    prev_page: Optional[int] = Field(None, description="Номер предыдущей страницы")    @classmethod    def create(        cls,        items: List[T],        total: int,        page: int,        per_page: int    ) -> "PaginatedResponse[T]":        """        Создание объекта пагинированного ответа.        Args:            items: Список элементов            total: Общее количество элементов            page: Текущая страница            per_page: Размер страницы        Returns:            PaginatedResponse[T]: Объект с пагинацией        """        pages = (total + per_page - 1) // per_page if total > 0 else 0        has_next = page < pages        has_prev = page > 1        return cls(            items=items,            total=total,            page=page,            per_page=per_page,            pages=pages,            has_next=has_next,            has_prev=has_prev,            next_page=page + 1 if has_next else None,            prev_page=page - 1 if has_prev else None        )class MessageResponse(BaseModel):    """    Схема для простых сообщений.    Используется для ответов, содержащих только текстовое сообщение.    """    message: str = Field(..., min_length=1, description="Текст сообщения")    success: bool = Field(True, description="Успешность операции")    code: Optional[str] = Field(None, description="Код ответа для программной обработки")    details: Optional[Dict[str, Any]] = Field(None, description="Дополнительные детали")    @field_validator('message')    @classmethod    def validate_message(cls, v: str) -> str:        """Валидация сообщения."""        if not v.strip():            raise ValueError('Message cannot be empty')        return v.strip()class ErrorResponse(BaseModel):    """    Схема для ошибок.    Стандартизированный формат ошибок API.    """    error: str = Field(..., description="Описание ошибки")    error_code: str = Field(..., description="Код ошибки")    details: Optional[Dict[str, Any]] = Field(None, description="Дополнительные детали ошибки")    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Время возникновения ошибки")    request_id: Optional[str] = Field(None, description="Идентификатор запроса для отладки")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class ValidationErrorResponse(BaseModel):    """    Схема для ошибок валидации.    Расширенная информация об ошибках валидации полей.    """    error: str = Field("Validation Error", description="Тип ошибки")    error_code: str = Field("VALIDATION_ERROR", description="Код ошибки")    fields: List[Dict[str, Any]] = Field(..., description="Список полей с ошибками")    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Время ошибки")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class HealthCheckResponse(BaseModel):    """    Схема ответа проверки здоровья системы.    """    status: str = Field(..., description="Статус системы (healthy/unhealthy)")    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Время проверки")    version: str = Field(..., description="Версия приложения")    uptime_seconds: int = Field(..., ge=0, description="Время работы в секундах")    # Статус компонентов    database: str = Field(..., description="Статус базы данных")    redis: Optional[str] = Field(None, description="Статус Redis")    external_apis: Dict[str, str] = Field(default_factory=dict, description="Статус внешних API")    # Метрики    memory_usage_mb: Optional[float] = Field(None, description="Использование памяти в МБ")    cpu_usage_percent: Optional[float] = Field(None, description="Использование CPU в %")    active_connections: Optional[int] = Field(None, description="Количество активных соединений")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class SearchParams(BaseModel):    """    Параметры поиска.    Базовые параметры для поисковых запросов.    """    query: Optional[str] = Field(None, max_length=200, description="Поисковый запрос")    sort_by: str = Field("created_at", description="Поле для сортировки")    sort_order: str = Field("desc", pattern="^(asc|desc)$", description="Направление сортировки")    filters: Optional[Dict[str, Any]] = Field(None, description="Дополнительные фильтры")    @field_validator('query')    @classmethod    def validate_query(cls, v: Optional[str]) -> Optional[str]:        """Валидация поискового запроса."""        if v is not None:            v = v.strip()            if len(v) < 2:                raise ValueError('Search query must be at least 2 characters long')            return v        return v    @field_validator('sort_by')    @classmethod    def validate_sort_by(cls, v: str) -> str:        """Валидация поля сортировки."""        # Базовая проверка названия поля        allowed_fields = [            'id', 'created_at', 'updated_at', 'name', 'price',            'status', 'amount', 'date', 'title', 'email', 'username'        ]        if v not in allowed_fields:            raise ValueError(f'Sort field must be one of: {", ".join(allowed_fields)}')        return vclass BulkOperationRequest(BaseModel):    """    Запрос массовой операции.    Используется для выполнения операций над множеством объектов.    """    ids: List[int] = Field(..., min_items=1, max_items=100, description="Список ID объектов")    operation: str = Field(..., min_length=1, description="Тип операции")    parameters: Optional[Dict[str, Any]] = Field(None, description="Параметры операции")    @field_validator('ids')    @classmethod    def validate_ids(cls, v: List[int]) -> List[int]:        """Валидация списка ID."""        # Убираем дубликаты        unique_ids = list(set(v))        if len(unique_ids) != len(v):            raise ValueError('Duplicate IDs are not allowed')        # Проверяем что все ID положительные        if any(id_val <= 0 for id_val in unique_ids):            raise ValueError('All IDs must be positive')        return unique_ids    @field_validator('operation')    @classmethod    def validate_operation(cls, v: str) -> str:        """Валидация типа операции."""        allowed_operations = [            'delete', 'activate', 'deactivate', 'update', 'export',            'cancel', 'complete', 'process', 'verify', 'approve'        ]        if v.lower() not in allowed_operations:            raise ValueError(f'Operation must be one of: {", ".join(allowed_operations)}')        return v.lower()class BulkOperationResponse(BaseModel):    """    Ответ массовой операции.    """    total_processed: int = Field(..., ge=0, description="Общее количество обработанных")    successful: int = Field(..., ge=0, description="Успешно обработано")    failed: int = Field(..., ge=0, description="Не удалось обработать")    errors: List[Dict[str, Any]] = Field(default_factory=list, description="Список ошибок")    results: List[Dict[str, Any]] = Field(default_factory=list, description="Результаты операций")    @field_validator('successful', 'failed')    @classmethod    def validate_counts(cls, v: int) -> int:        """Валидация счетчиков."""        if v < 0:            raise ValueError('Count cannot be negative')        return v    def model_post_init(self, __context: Any) -> None:        """Проверка корректности данных после инициализации."""        if self.successful + self.failed != self.total_processed:            raise ValueError('Sum of successful and failed must equal total_processed')class ApiVersionResponse(BaseModel):    """    Информация о версии API.    """    version: str = Field(..., description="Версия API")    build: str = Field(..., description="Номер сборки")    build_date: datetime = Field(..., description="Дата сборки")    environment: str = Field(..., description="Окружение")    features: List[str] = Field(default_factory=list, description="Доступные функции")    deprecations: List[Dict[str, Any]] = Field(default_factory=list, description="Устаревшие API")    @field_serializer('build_date')    def serialize_build_date(self, value: datetime) -> str:        return value.isoformat()class StatusResponse(BaseModel):    """    Схема ответа статуса операции.    """    status: str = Field(..., description="Статус операции")    message: str = Field(..., description="Сообщение")    data: Optional[Dict[str, Any]] = Field(None, description="Дополнительные данные")    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Время операции")    @field_serializer('timestamp')    def serialize_timestamp(self, value: datetime) -> str:        return value.isoformat()class FileUploadResponse(BaseModel):    """    Схема ответа загрузки файла.    """    filename: str = Field(..., description="Имя файла")    file_size: int = Field(..., ge=0, description="Размер файла в байтах")    content_type: str = Field(..., description="MIME тип файла")    file_url: str = Field(..., description="URL файла")    upload_id: str = Field(..., description="ID загрузки")    uploaded_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Время загрузки")    @field_serializer('uploaded_at')    def serialize_uploaded_at(self, value: datetime) -> str:        return value.isoformat()