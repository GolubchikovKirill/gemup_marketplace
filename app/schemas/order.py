"""Схемы для заказов.Содержит все схемы для работы с заказами и элементами заказов:создание, обновление, отображение и фильтрация."""from datetime import datetimefrom decimal import Decimalfrom typing import Optional, List, Literalfrom pydantic import BaseModel, Field, ConfigDict, field_serializer, field_validatorfrom app.models.models import OrderStatusclass OrderItemBase(BaseModel):    """Базовая схема элемента заказа."""    proxy_product_id: int = Field(..., gt=0, description="ID продукта прокси")    quantity: int = Field(..., gt=0, le=1000, description="Количество")    generation_params: Optional[str] = Field(None, max_length=1000, description="Параметры генерации")class OrderItemCreate(OrderItemBase):    """Схема создания элемента заказа."""    passclass OrderItemUpdate(BaseModel):    """Схема обновления элемента заказа."""    quantity: Optional[int] = Field(None, gt=0, le=1000, description="Количество")    generation_params: Optional[str] = Field(None, max_length=1000, description="Параметры генерации")class OrderItemResponse(BaseModel):    """Схема ответа элемента заказа."""    model_config = ConfigDict(from_attributes=True)    id: int    order_id: int    proxy_product_id: int    quantity: int    unit_price: Decimal    total_price: Decimal    generation_params: Optional[str] = None    created_at: datetime    # Дополнительная информация о продукте (если загружена)    product_name: Optional[str] = Field(None, description="Название продукта")    proxy_category: Optional[str] = Field(None, description="Категория прокси")    country_name: Optional[str] = Field(None, description="Страна")    duration_days: Optional[int] = Field(None, description="Длительность в днях")    @field_serializer('unit_price', 'total_price')    def serialize_decimal(self, value: Decimal) -> str:        return f"{value:.8f}"    @field_serializer('created_at')    def serialize_datetime(self, value: datetime) -> str:        return value.isoformat()class OrderBase(BaseModel):    """Базовая схема заказа."""    currency: str = Field(default="USD", max_length=3, description="Валюта")    payment_method: Optional[str] = Field(None, max_length=50, description="Метод оплаты")    @field_validator('currency')    @classmethod    def validate_currency(cls, v: str) -> str:        """Валидация валюты заказа."""        allowed_currencies = ['USD', 'EUR', 'BTC', 'ETH']        if v.upper() not in allowed_currencies:            raise ValueError(f'Currency must be one of: {", ".join(allowed_currencies)}')        return v.upper()    @field_validator('payment_method')    @classmethod    def validate_payment_method(cls, v: Optional[str]) -> Optional[str]:        """Валидация способа оплаты."""        if v is not None:            allowed_methods = ['balance', 'cryptomus', 'stripe', 'paypal', 'crypto']            if v.lower() not in allowed_methods:                raise ValueError(f'Payment method must be one of: {", ".join(allowed_methods)}')            return v.lower()        return vclass OrderCreate(OrderBase):    """Схема создания заказа."""    items: List[OrderItemCreate] = Field(..., min_items=1, max_items=100, description="Элементы заказа")    expires_at: Optional[datetime] = Field(None, description="Время истечения заказа")    @field_validator('items')    @classmethod    def validate_items(cls, v: List[OrderItemCreate]) -> List[OrderItemCreate]:        """Валидация элементов заказа."""        if not v:            raise ValueError('Order must contain at least one item')        # Проверяем уникальность продуктов        product_ids = [item.proxy_product_id for item in v]        if len(set(product_ids)) != len(product_ids):            raise ValueError('Duplicate products in order items')        return v    @field_validator('expires_at')    @classmethod    def validate_expires_at(cls, v: Optional[datetime]) -> Optional[datetime]:        """Валидация времени истечения."""        if v and v <= datetime.now():            raise ValueError('Expiration time must be in the future')        return vclass OrderCreateFromCart(OrderBase):    """Схема создания заказа из корзины."""    cart_item_ids: Optional[List[int]] = Field(None, description="ID элементов корзины (если не указано - вся корзина)")class OrderUpdate(BaseModel):    """Схема обновления заказа."""    status: Optional[OrderStatus] = Field(None, description="Статус заказа")    payment_method: Optional[str] = Field(None, max_length=50, description="Метод оплаты")    expires_at: Optional[datetime] = Field(None, description="Время истечения заказа")    @field_validator('expires_at')    @classmethod    def validate_expires_at(cls, v: Optional[datetime]) -> Optional[datetime]:        """Валидация времени истечения."""        if v and v <= datetime.now():            raise ValueError('Expiration time must be in the future')        return v    @field_validator('payment_method')    @classmethod    def validate_payment_method(cls, v: Optional[str]) -> Optional[str]:        """Валидация способа оплаты."""        if v is not None:            allowed_methods = ['balance', 'cryptomus', 'stripe', 'paypal', 'crypto']            if v.lower() not in allowed_methods:                raise ValueError(f'Payment method must be one of: {", ".join(allowed_methods)}')            return v.lower()        return vclass OrderResponse(BaseModel):    """Схема ответа заказа."""    model_config = ConfigDict(from_attributes=True)    id: int    order_number: str    user_id: int    total_amount: Decimal    currency: str    status: OrderStatus    payment_method: Optional[str] = None    expires_at: Optional[datetime] = None    created_at: datetime    updated_at: datetime    @field_serializer('total_amount')    def serialize_total_amount(self, value: Decimal) -> str:        return f"{value:.8f}"    @field_serializer('created_at', 'updated_at', 'expires_at')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        return value.isoformat() if value else Noneclass OrderWithItems(OrderResponse):    """Заказ с элементами."""    order_items: List[OrderItemResponse] = Field(default_factory=list, description="Позиции заказа")    # Вычисляемые поля    items_count: int = Field(0, description="Количество позиций")    total_proxies: int = Field(0, description="Общее количество прокси")    def __init__(self, **data):        super().__init__(**data)        # Вычисляем количество позиций и прокси        if hasattr(self, 'order_items') and self.order_items:            self.items_count = len(self.order_items)            self.total_proxies = sum(item.quantity for item in self.order_items)class OrderWithDetails(OrderWithItems):    """Заказ с полной детализацией."""    user: Optional["UserResponse"] = None    transactions: List["TransactionResponse"] = []    proxy_purchases: List["ProxyPurchaseResponse"] = []class OrderFilter(BaseModel):    """Фильтр для поиска заказов."""    user_id: Optional[int] = Field(None, gt=0, description="ID пользователя")    status: Optional[OrderStatus] = Field(None, description="Статус заказа")    payment_method: Optional[str] = Field(None, max_length=50, description="Метод оплаты")    min_amount: Optional[Decimal] = Field(None, ge=0, description="Минимальная сумма")    max_amount: Optional[Decimal] = Field(None, ge=0, description="Максимальная сумма")    created_after: Optional[datetime] = Field(None, description="Создан после даты")    created_before: Optional[datetime] = Field(None, description="Создан до даты")    expires_after: Optional[datetime] = Field(None, description="Истекает после даты")    expires_before: Optional[datetime] = Field(None, description="Истекает до даты")    order_number: Optional[str] = Field(None, max_length=50, description="Номер заказа")    @field_validator('min_amount', 'max_amount')    @classmethod    def validate_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:        """Валидация сумм."""        if v is not None and v < 0:            raise ValueError('Amount cannot be negative')        return vclass OrderListResponse(BaseModel):    """Ответ со списком заказов."""    orders: List[OrderResponse]    total: int = Field(ge=0, description="Общее количество заказов")    page: int = Field(ge=1, description="Номер страницы")    per_page: int = Field(ge=1, le=100, description="Количество на странице")    pages: int = Field(ge=0, description="Общее количество страниц")class OrderStatsResponse(BaseModel):    """Статистика заказов."""    total_orders: int = Field(ge=0, description="Общее количество заказов")    pending_orders: int = Field(ge=0, description="Заказы в ожидании")    paid_orders: int = Field(ge=0, description="Оплаченные заказы")    processing_orders: int = Field(ge=0, description="Обрабатываемые заказы")    completed_orders: int = Field(ge=0, description="Завершенные заказы")    cancelled_orders: int = Field(ge=0, description="Отмененные заказы")    failed_orders: int = Field(ge=0, description="Неудачные заказы")    refunded_orders: int = Field(ge=0, description="Возвращенные заказы")    total_revenue: str = Field(..., description="Общая выручка")    average_order_value: str = Field(..., description="Средняя стоимость заказа")    period_days: int = Field(ge=1, description="Период в днях")class OrderSummary(BaseModel):    """Сводка заказов пользователя."""    total_orders: int = Field(..., ge=0, description="Общее количество заказов")    total_spent: Decimal = Field(..., ge=0, description="Общая потрачена сумма")    completed_orders: int = Field(..., ge=0, description="Выполненных заказов")    cancelled_orders: int = Field(..., ge=0, description="Отмененных заказов")    pending_orders: int = Field(..., ge=0, description="Ожидающих заказов")    currency: str = Field("USD", description="Валюта")    # Статистика по периодам    orders_this_month: int = Field(0, ge=0, description="Заказов в этом месяце")    spent_this_month: Decimal = Field(Decimal('0.00'), ge=0, description="Потрачено в этом месяце")    # Дополнительная информация    average_order_value: Decimal = Field(Decimal('0.00'), ge=0, description="Средняя стоимость заказа")    last_order_date: Optional[datetime] = Field(None, description="Дата последнего заказа")    @field_serializer('total_spent', 'spent_this_month', 'average_order_value')    def serialize_amounts(self, value: Decimal) -> str:        """Сериализация денежных сумм."""        return f"{value:.8f}"    @field_serializer('last_order_date')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        return value.isoformat() if value else Noneclass OrderSummaryResponse(OrderSummary):    """Схема ответа сводки заказов."""    period_days: int = Field(30, ge=1, le=365, description="Период статистики в днях")class OrderStatusUpdateRequest(BaseModel):    """Схема запроса обновления статуса заказа."""    status: OrderStatus = Field(..., description="Новый статус заказа")    reason: Optional[str] = Field(None, max_length=500, description="Причина изменения статуса")    notify_user: bool = Field(True, description="Уведомить пользователя")    @field_validator('reason')    @classmethod    def validate_reason(cls, v: Optional[str]) -> Optional[str]:        """Валидация причины изменения статуса."""        if v is not None and not v.strip():            return None        return vclass OrderActionRequest(BaseModel):    """Запрос действия с заказом."""    action: Literal["cancel", "refund", "complete", "process"] = Field(..., description="Действие")    reason: Optional[str] = Field(None, max_length=500, description="Причина действия")    refund_amount: Optional[Decimal] = Field(None, ge=0, description="Сумма возврата")    @field_validator('refund_amount')    @classmethod    def validate_refund_amount(cls, v: Optional[Decimal], info) -> Optional[Decimal]:        """Валидация суммы возврата."""        if v is not None:            action = info.data.get('action')            if action != 'refund':                raise ValueError('Refund amount can only be specified for refund action')            if v <= 0:                raise ValueError('Refund amount must be positive')        return vclass OrderBulkAction(BaseModel):    """Массовые действия с заказами."""    order_ids: List[int] = Field(..., min_items=1, max_items=100, description="ID заказов")    action: Literal["cancel", "complete", "process"] = Field(..., description="Действие")    reason: Optional[str] = Field(None, max_length=500, description="Причина действия")    @field_validator('order_ids')    @classmethod    def validate_order_ids(cls, v: List[int]) -> List[int]:        """Валидация ID заказов."""        if len(set(v)) != len(v):            raise ValueError('Order IDs must be unique')        return vclass OrderCancellation(BaseModel):    """Схема отмены заказа."""    reason: str = Field(..., min_length=1, max_length=500, description="Причина отмены")    refund_amount: Optional[Decimal] = Field(None, ge=0, description="Сумма возврата")    admin_comment: Optional[str] = Field(None, max_length=1000, description="Комментарий администратора")    @field_validator('reason')    @classmethod    def validate_reason(cls, v: str) -> str:        """Валидация причины отмены."""        if not v.strip():            raise ValueError('Cancellation reason cannot be empty')        return v.strip()class OrderCalculationRequest(BaseModel):    """Запрос расчета стоимости заказа."""    items: List[OrderItemCreate] = Field(..., min_items=1, max_items=100, description="Элементы заказа")    promo_code: Optional[str] = Field(None, max_length=50, description="Промокод")    @field_validator('items')    @classmethod    def validate_items(cls, v: List[OrderItemCreate]) -> List[OrderItemCreate]:        """Валидация элементов заказа."""        if not v:            raise ValueError('Calculation must contain at least one item')        # Проверяем уникальность продуктов        product_ids = [item.proxy_product_id for item in v]        if len(set(product_ids)) != len(product_ids):            raise ValueError('Duplicate products in calculation items')        return vclass OrderCalculationResponse(BaseModel):    """Ответ расчета стоимости заказа."""    items: List[dict] = Field(..., description="Детали элементов")    subtotal: str = Field(..., description="Подытог")    discount: str = Field(default="0.00000000", description="Скидка")    total: str = Field(..., description="Итого")    currency: str = Field(default="USD", description="Валюта")    promo_code_applied: Optional[str] = Field(None, description="Примененный промокод")class PublicOrderInfoResponse(BaseModel):    """Схема публичной информации о заказе."""    order_number: str = Field(..., description="Номер заказа")    status: OrderStatus = Field(..., description="Статус заказа")    total_amount: str = Field(..., description="Общая сумма")    currency: str = Field(..., description="Валюта")    created_at: str = Field(..., description="Дата создания")class OrderExportRequest(BaseModel):    """Запрос экспорта заказов."""    filter_params: Optional[OrderFilter] = Field(None, description="Параметры фильтрации")    format: Literal["csv", "xlsx", "json"] = Field(default="csv", description="Формат экспорта")    include_items: bool = Field(default=True, description="Включать элементы заказов")    include_user_info: bool = Field(default=False, description="Включать информацию о пользователе")# Forward references для связанных моделейfrom typing import TYPE_CHECKINGif TYPE_CHECKING:    from .user import UserResponse    from .transaction import TransactionResponse    from .proxy_purchase import ProxyPurchaseResponse