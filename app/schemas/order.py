"""Схемы для заказов.Содержит схемы для управления заказами пользователей,включая создание, обновление и отслеживание статуса заказов."""from datetime import datetimefrom decimal import Decimalfrom typing import Optional, Listfrom pydantic import BaseModel, Field, ConfigDict, field_serializer, field_validatorfrom app.models.models import OrderStatusclass OrderBase(BaseModel):    """    Базовая схема заказа.    Содержит основную информацию о заказе.    """    total_amount: Decimal = Field(..., gt=0, description="Общая сумма заказа")    currency: str = Field("USD", max_length=10, description="Валюта заказа")    notes: Optional[str] = Field(None, max_length=1000, description="Примечания к заказу")    @field_validator('total_amount')    @classmethod    def validate_total_amount(cls, v: Decimal) -> Decimal:        """Валидация общей суммы заказа."""        if v <= 0:            raise ValueError('Order total amount must be positive')        if v > Decimal('50000.00'):            raise ValueError('Order total amount cannot exceed $50,000.00')        return v    @field_validator('currency')    @classmethod    def validate_currency(cls, v: str) -> str:        """Валидация валюты заказа."""        allowed_currencies = ['USD', 'EUR']        if v.upper() not in allowed_currencies:            raise ValueError(f'Currency must be one of: {", ".join(allowed_currencies)}')        return v.upper()class OrderCreate(OrderBase):    """    Схема создания заказа.    Используется при создании нового заказа из корзины пользователя.    """    order_number: str = Field(..., min_length=1, max_length=50, description="Уникальный номер заказа")    user_id: int = Field(..., gt=0, description="ID пользователя")    status: OrderStatus = Field(OrderStatus.PENDING, description="Начальный статус заказа")    @field_validator('order_number')    @classmethod    def validate_order_number(cls, v: str) -> str:        """Валидация номера заказа."""        if not v.strip():            raise ValueError('Order number cannot be empty')        # Проверяем формат номера заказа (например, ORD-YYYYMMDD-XXXXX)        import re        if not re.match(r'^ORD-\d{8}-[A-Z0-9]{5,8}$', v):            raise ValueError('Invalid order number format')        return v.upper()class OrderUpdate(BaseModel):    """    Схема обновления заказа.    Позволяет обновлять статус заказа и дополнительную информацию.    """    status: Optional[OrderStatus] = Field(None, description="Новый статус заказа")    payment_method: Optional[str] = Field(None, max_length=50, description="Способ оплаты")    payment_id: Optional[str] = Field(None, max_length=255, description="ID платежа")    notes: Optional[str] = Field(None, max_length=1000, description="Обновленные примечания")    expires_at: Optional[datetime] = Field(None, description="Срок действия заказа")    @field_validator('status')    @classmethod    def validate_status_transition(cls, v: Optional[OrderStatus]) -> Optional[OrderStatus]:        """Валидация перехода статуса заказа."""        if v is not None:            # Здесь можно добавить логику проверки допустимых переходов            # Например, нельзя изменить статус с COMPLETED на PENDING            return v        return v    @field_validator('payment_method')    @classmethod    def validate_payment_method(cls, v: Optional[str]) -> Optional[str]:        """Валидация способа оплаты."""        if v is not None:            allowed_methods = ['balance', 'cryptomus', 'stripe', 'paypal']            if v.lower() not in allowed_methods:                raise ValueError(f'Payment method must be one of: {", ".join(allowed_methods)}')            return v.lower()        return vclass OrderItemResponse(BaseModel):    """    Схема элемента заказа.    Представляет отдельную позицию в заказе.    """    model_config = ConfigDict(from_attributes=True)    id: int    proxy_product_id: int    quantity: int    unit_price: Decimal    total_price: Decimal    generation_params: Optional[str]    # Информация о продукте    product_name: Optional[str] = Field(None, description="Название продукта")    proxy_category: Optional[str] = Field(None, description="Категория прокси")    country_name: Optional[str] = Field(None, description="Страна")    duration_days: Optional[int] = Field(None, description="Длительность в днях")    @field_serializer('unit_price', 'total_price')    def serialize_prices(self, value: Decimal) -> str:        """Сериализация цен."""        return f"{value:.8f}"class OrderResponse(BaseModel):    """    Схема ответа заказа.    Содержит полную информацию о заказе для API ответов.    """    model_config = ConfigDict(from_attributes=True)    id: int    order_number: str    user_id: int    total_amount: Decimal    currency: str    status: OrderStatus    payment_method: Optional[str]    payment_id: Optional[str]    notes: Optional[str]    expires_at: Optional[datetime]    created_at: datetime    updated_at: datetime    # Элементы заказа    order_items: List[OrderItemResponse] = Field(default_factory=list, description="Позиции заказа")    # Вычисляемые поля    items_count: Optional[int] = Field(None, description="Количество позиций")    total_proxies: Optional[int] = Field(None, description="Общее количество прокси")    estimated_delivery: Optional[str] = Field(None, description="Ожидаемое время доставки")    @field_serializer('total_amount')    def serialize_amount(self, value: Decimal) -> str:        """Сериализация суммы заказа."""        return f"{value:.8f}"    @field_serializer('created_at', 'updated_at', 'expires_at')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        """Сериализация datetime в ISO формат."""        return value.isoformat() if value else None    def __init__(self, **data):        super().__init__(**data)        # Вычисляем количество позиций и прокси        if self.order_items:            self.items_count = len(self.order_items)            self.total_proxies = sum(item.quantity for item in self.order_items)        # Определяем ожидаемое время доставки        if self.status == OrderStatus.PAID:            self.estimated_delivery = "Immediate"        elif self.status == OrderStatus.PENDING:            self.estimated_delivery = "After payment"        else:            self.estimated_delivery = "Processing"class OrderSummary(BaseModel):    """    Сводка заказов пользователя.    Содержит агрегированную статистику по заказам.    """    total_orders: int = Field(..., ge=0, description="Общее количество заказов")    total_spent: Decimal = Field(..., ge=0, description="Общая потрачена сумма")    completed_orders: int = Field(..., ge=0, description="Выполненных заказов")    cancelled_orders: int = Field(..., ge=0, description="Отмененных заказов")    pending_orders: int = Field(..., ge=0, description="Ожидающих заказов")    currency: str = Field("USD", description="Валюта")    # Статистика по периодам    orders_this_month: int = Field(0, ge=0, description="Заказов в этом месяце")    spent_this_month: Decimal = Field(Decimal('0.00'), ge=0, description="Потрачено в этом месяце")    # Дополнительная информация    average_order_value: Decimal = Field(Decimal('0.00'), ge=0, description="Средняя стоимость заказа")    last_order_date: Optional[datetime] = Field(None, description="Дата последнего заказа")    @field_serializer('total_spent', 'spent_this_month', 'average_order_value')    def serialize_amounts(self, value: Decimal) -> str:        """Сериализация денежных сумм."""        return f"{value:.2f}"    @field_serializer('last_order_date')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        return value.isoformat() if value else None# ДОБАВЛЕНО: Недостающие схемы для роутовclass OrderSummaryResponse(OrderSummary):  # ИСПРАВЛЕНО: создано для роутов    """    Схема ответа сводки заказов.    Наследует от OrderSummary для совместимости с роутами.    """    period_days: int = Field(30, ge=1, le=365, description="Период статистики в днях")class OrderStatusUpdateRequest(BaseModel):  # ДОБАВЛЕНО: для роутов    """    Схема запроса обновления статуса заказа.    """    status: OrderStatus = Field(..., description="Новый статус заказа")    reason: Optional[str] = Field(None, max_length=500, description="Причина изменения статуса")    notify_user: bool = Field(True, description="Уведомить пользователя")    @field_validator('reason')    @classmethod    def validate_reason(cls, v: Optional[str]) -> Optional[str]:        """Валидация причины изменения статуса."""        if v is not None and not v.strip():            return None        return vclass PublicOrderInfoResponse(BaseModel):  # ДОБАВЛЕНО: для публичного endpoint    """    Схема публичной информации о заказе.    Ограниченная информация без чувствительных данных.    """    order_number: str = Field(..., description="Номер заказа")    status: OrderStatus = Field(..., description="Статус заказа")    total_amount: str = Field(..., description="Общая сумма")    currency: str = Field(..., description="Валюта")    created_at: str = Field(..., description="Дата создания")class OrderListResponse(BaseModel):    """    Схема списка заказов с пагинацией.    """    orders: List[OrderResponse] = Field(..., description="Список заказов")    total: int = Field(..., ge=0, description="Общее количество заказов")    page: int = Field(..., ge=1, description="Текущая страница")    size: int = Field(..., ge=1, le=100, description="Размер страницы")    pages: int = Field(..., ge=1, description="Общее количество страниц")class OrderFilter(BaseModel):    """    Фильтр для поиска заказов.    """    status: Optional[OrderStatus] = Field(None, description="Статус заказа")    payment_method: Optional[str] = Field(None, description="Способ оплаты")    min_amount: Optional[Decimal] = Field(None, ge=0, description="Минимальная сумма")    max_amount: Optional[Decimal] = Field(None, ge=0, description="Максимальная сумма")    date_from: Optional[datetime] = Field(None, description="Начальная дата")    date_to: Optional[datetime] = Field(None, description="Конечная дата")    search: Optional[str] = Field(None, max_length=100, description="Поиск по номеру заказа")    @field_validator('date_to')    @classmethod    def validate_date_range(cls, v: Optional[datetime], info) -> Optional[datetime]:        """Валидация диапазона дат."""        if v and 'date_from' in info.data and info.data['date_from']:            if v < info.data['date_from']:                raise ValueError('End date cannot be before start date')        return vclass OrderStatusUpdate(BaseModel):    """    Схема обновления статуса заказа.    Используется для изменения статуса заказа администраторами или системой.    """    status: OrderStatus = Field(..., description="Новый статус заказа")    reason: Optional[str] = Field(None, max_length=500, description="Причина изменения статуса")    notify_user: bool = Field(True, description="Уведомить пользователя об изменении")    @field_validator('reason')    @classmethod    def validate_reason(cls, v: Optional[str]) -> Optional[str]:        """Валидация причины изменения статуса."""        if v is not None and not v.strip():            return None        return vclass OrderCancellation(BaseModel):    """    Схема отмены заказа.    """    reason: str = Field(..., min_length=1, max_length=500, description="Причина отмены")    refund_amount: Optional[Decimal] = Field(None, ge=0, description="Сумма возврата")    admin_comment: Optional[str] = Field(None, max_length=1000, description="Комментарий администратора")    @field_validator('reason')    @classmethod    def validate_reason(cls, v: str) -> str:        """Валидация причины отмены."""        if not v.strip():            raise ValueError('Cancellation reason cannot be empty')        return v.strip()