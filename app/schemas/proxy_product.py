from pydantic import BaseModel, Field, field_validator, ConfigDictfrom typing import Optionalfrom datetime import datetimefrom decimal import Decimalfrom app.models.models import ProxyType, SessionType, ProviderTypeclass ProxyProductBase(BaseModel):    name: str = Field(..., min_length=1, max_length=200)    description: Optional[str] = None    proxy_type: ProxyType    session_type: SessionType    provider: ProviderType    country_code: str = Field(..., min_length=2, max_length=2)    country_name: str = Field(..., min_length=1, max_length=100)    city: Optional[str] = Field(None, max_length=100)    price_per_proxy: Decimal = Field(..., gt=0, decimal_places=8)    min_quantity: int = Field(default=1, ge=1)    max_quantity: int = Field(default=1000, ge=1)    duration_days: int = Field(..., gt=0)    max_threads: int = Field(default=1, ge=1)    bandwidth_limit_gb: Optional[int] = Field(None, ge=1)    @classmethod    @field_validator('country_code')    def country_code_uppercase(cls, v: str) -> str:        return v.upper()    @classmethod    @field_validator('max_quantity')    def max_quantity_gte_min_quantity(cls, v: int, info) -> int:        if 'min_quantity' in info.data and v < info.data['min_quantity']:            raise ValueError('max_quantity must be greater than or equal to min_quantity')        return vclass ProxyProductCreate(ProxyProductBase):    stock_available: int = Field(default=0, ge=0)    is_featured: bool = Field(default=False)    provider_product_id: Optional[str] = None    provider_metadata: Optional[str] = Noneclass ProxyProductUpdate(BaseModel):    name: Optional[str] = Field(None, min_length=1, max_length=200)    description: Optional[str] = None    price_per_proxy: Optional[Decimal] = Field(None, gt=0, decimal_places=8)    min_quantity: Optional[int] = Field(None, ge=1)    max_quantity: Optional[int] = Field(None, ge=1)    duration_days: Optional[int] = Field(None, gt=0)    max_threads: Optional[int] = Field(None, ge=1)    bandwidth_limit_gb: Optional[int] = Field(None, ge=1)    stock_available: Optional[int] = Field(None, ge=0)    is_active: Optional[bool] = None    is_featured: Optional[bool] = None    provider_metadata: Optional[str] = Noneclass ProxyProductResponse(ProxyProductBase):    model_config = ConfigDict(from_attributes=True)    id: int    stock_available: int    is_active: bool    is_featured: bool    provider_product_id: Optional[str]    provider_metadata: Optional[str]    created_at: datetime    updated_at: datetimeclass ProxyProductPublic(BaseModel):    """Публичная информация о продукте для неавторизованных пользователей"""    model_config = ConfigDict(from_attributes=True)    id: int    name: str    description: Optional[str]    proxy_type: ProxyType    session_type: SessionType    provider: ProviderType    country_code: str    country_name: str    city: Optional[str]    price_per_proxy: Decimal    min_quantity: int    max_quantity: int    duration_days: int    max_threads: int    bandwidth_limit_gb: Optional[int]    is_featured: bool    stock_available: intclass ProxyProductFilters(BaseModel):    """Фильтры для поиска продуктов"""    proxy_type: Optional[ProxyType] = None    session_type: Optional[SessionType] = None    provider: Optional[ProviderType] = None    country_code: Optional[str] = None    city: Optional[str] = None    featured_only: bool = False    min_price: Optional[Decimal] = None    max_price: Optional[Decimal] = None    skip: int = 0    limit: int = 100class CountryInfo(BaseModel):    """Информация о стране"""    code: str    name: strclass ProxyGenerationParams(BaseModel):    """Параметры для генерации прокси"""    format_type: str = Field(default="ip:port:user:pass", description="Формат вывода прокси")    include_auth: bool = Field(default=True, description="Включить авторизацию в список")    separator: str = Field(default="\n", description="Разделитель между прокси")