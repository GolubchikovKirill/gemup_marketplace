"""Схемы для финансовых транзакций.Содержит схемы для работы с транзакциями, платежами и webhook-уведомлениямиот платежных систем. Поддерживает различные типы транзакций и статусы."""from datetime import datetimefrom decimal import Decimalfrom typing import Optional, Listfrom pydantic import BaseModel, Field, ConfigDict, field_serializer, field_validatorfrom app.models.models import TransactionType, TransactionStatusclass TransactionBase(BaseModel):    """    Базовая схема транзакции.    Содержит общие поля для всех типов финансовых операций.    """    amount: Decimal = Field(..., gt=0, description="Сумма транзакции")    currency: str = Field("USD", max_length=10, description="Валюта транзакции")    transaction_type: TransactionType = Field(..., description="Тип транзакции")    description: Optional[str] = Field(None, max_length=500, description="Описание транзакции")    @field_validator('amount')    @classmethod    def validate_amount(cls, v: Decimal) -> Decimal:        """Валидация суммы транзакции."""        if v <= 0:            raise ValueError('Transaction amount must be positive')        if v > Decimal('100000.00'):            raise ValueError('Transaction amount cannot exceed 100,000.00')        return v    @field_validator('currency')    @classmethod    def validate_currency(cls, v: str) -> str:        """Валидация валюты."""        allowed_currencies = ['USD', 'EUR', 'BTC', 'ETH', 'USDT']        if v.upper() not in allowed_currencies:            raise ValueError(f'Currency must be one of: {", ".join(allowed_currencies)}')        return v.upper()class TransactionCreate(TransactionBase):    """    Схема создания транзакции.    Используется для создания новых транзакций в системе.    Содержит дополнительную информацию для интеграции с платежными провайдерами.    """    user_id: int = Field(..., gt=0, description="ID пользователя")    order_id: Optional[int] = Field(None, gt=0, description="ID связанного заказа")    payment_provider: str = Field("cryptomus", max_length=50, description="Платежный провайдер")    external_transaction_id: Optional[str] = Field(None, max_length=255, description="Внешний ID транзакции")    payment_url: Optional[str] = Field(None, max_length=500, description="URL для оплаты")    provider_metadata: Optional[str] = Field(None, description="Метаданные провайдера в JSON формате")    @field_validator('payment_provider')    @classmethod    def validate_payment_provider(cls, v: str) -> str:        """Валидация платежного провайдера."""        allowed_providers = ['cryptomus', 'stripe', 'paypal', 'coinbase']        if v.lower() not in allowed_providers:            raise ValueError(f'Payment provider must be one of: {", ".join(allowed_providers)}')        return v.lower()class TransactionUpdate(BaseModel):    """    Схема обновления транзакции.    Используется для изменения статуса транзакции и добавления    дополнительной информации от платежных провайдеров.    """    status: Optional[TransactionStatus] = Field(None, description="Новый статус транзакции")    external_transaction_id: Optional[str] = Field(None, max_length=255, description="Внешний ID транзакции")    payment_url: Optional[str] = Field(None, max_length=500, description="URL для оплаты")    provider_metadata: Optional[str] = Field(None, description="Обновленные метаданные провайдера")    completed_at: Optional[datetime] = Field(None, description="Время завершения транзакции")    @field_validator('status')    @classmethod    def validate_status_transition(cls, v: Optional[TransactionStatus]) -> Optional[TransactionStatus]:        """Валидация перехода статуса."""        if v is not None:            # Здесь можно добавить логику проверки допустимых переходов статусов            return v        return vclass TransactionResponse(BaseModel):    """    Схема ответа транзакции.    Содержит полную информацию о транзакции для API ответов.    """    model_config = ConfigDict(from_attributes=True)    id: int    transaction_id: str    user_id: int    order_id: Optional[int]    amount: Decimal    currency: str    transaction_type: TransactionType    status: TransactionStatus    payment_provider: str    external_transaction_id: Optional[str]    payment_url: Optional[str]    description: Optional[str]    provider_metadata: Optional[str]    created_at: datetime    updated_at: datetime    completed_at: Optional[datetime]    @field_serializer('amount')    def serialize_amount(self, value: Decimal) -> str:        """Сериализация суммы с высокой точностью."""        return f"{value:.8f}"    @field_serializer('created_at', 'updated_at', 'completed_at')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        """Сериализация datetime в ISO формат."""        return value.isoformat() if value else Noneclass PaymentCreateRequest(BaseModel):    """    Запрос на создание платежа.    Используется клиентами для инициации процесса пополнения баланса.    """    amount: Decimal = Field(..., gt=0, le=10000, description="Сумма платежа")    description: Optional[str] = Field(None, max_length=255, description="Описание платежа")    return_url: Optional[str] = Field(None, max_length=500, description="URL для возврата после оплаты")    callback_url: Optional[str] = Field(None, max_length=500, description="URL для webhook уведомлений")    @field_validator('amount')    @classmethod    def validate_payment_amount(cls, v: Decimal) -> Decimal:        """Валидация суммы платежа."""        if v < Decimal('1.00'):            raise ValueError('Minimum payment amount is $1.00')        if v > Decimal('10000.00'):            raise ValueError('Maximum payment amount is $10,000.00')        return vclass PaymentResponse(BaseModel):    """    Ответ при создании платежа.    Содержит информацию для перенаправления пользователя на страницу оплаты.    """    transaction_id: str = Field(..., description="Уникальный ID транзакции")    payment_url: str = Field(..., description="URL для перехода к оплате")    amount: str = Field(..., description="Сумма платежа")    currency: str = Field("USD", description="Валюта платежа")    status: str = Field(..., description="Статус платежа")    expires_at: Optional[datetime] = Field(None, description="Время истечения ссылки")    @field_serializer('expires_at')    def serialize_expires_at(self, value: Optional[datetime]) -> Optional[str]:        """Сериализация времени истечения."""        return value.isoformat() if value else Noneclass WebhookData(BaseModel):    """    Данные webhook от платежной системы.    Структура уведомлений от платежных провайдеров о статусе транзакций.    """    order_id: str = Field(..., description="ID заказа в системе провайдера")    status: str = Field(..., description="Статус платежа")    amount: str = Field(..., description="Сумма платежа")    currency: str = Field(..., description="Валюта платежа")    txid: Optional[str] = Field(None, description="ID транзакции провайдера")    signature: Optional[str] = Field(None, description="Подпись безопасности")    timestamp: Optional[str] = Field(None, description="Время события")    network: Optional[str] = Field(None, description="Сеть блокчейна")    fee: Optional[str] = Field(None, description="Комиссия")    @field_validator('status')    @classmethod    def validate_webhook_status(cls, v: str) -> str:        """Валидация статуса из webhook."""        allowed_statuses = ['paid', 'pending', 'failed', 'cancelled', 'refunded']        if v.lower() not in allowed_statuses:            raise ValueError(f'Webhook status must be one of: {", ".join(allowed_statuses)}')        return v.lower()class TransactionListResponse(BaseModel):    """    Схема списка транзакций с пагинацией.    """    transactions: List[TransactionResponse] = Field(..., description="Список транзакций")    total: int = Field(..., ge=0, description="Общее количество транзакций")    page: int = Field(..., ge=1, description="Текущая страница")    size: int = Field(..., ge=1, le=100, description="Размер страницы")    pages: int = Field(..., ge=1, description="Общее количество страниц")class TransactionFilter(BaseModel):    """    Фильтр для поиска транзакций.    """    transaction_type: Optional[TransactionType] = Field(None, description="Тип транзакции")    status: Optional[TransactionStatus] = Field(None, description="Статус транзакции")    payment_provider: Optional[str] = Field(None, description="Платежный провайдер")    min_amount: Optional[Decimal] = Field(None, ge=0, description="Минимальная сумма")    max_amount: Optional[Decimal] = Field(None, ge=0, description="Максимальная сумма")    date_from: Optional[datetime] = Field(None, description="Начальная дата")    date_to: Optional[datetime] = Field(None, description="Конечная дата")    search: Optional[str] = Field(None, max_length=100, description="Поиск по описанию")    @field_validator('date_to')    @classmethod    def validate_date_range(cls, v: Optional[datetime], info) -> Optional[datetime]:        """Валидация диапазона дат."""        if v and 'date_from' in info.data and info.data['date_from']:            if v < info.data['date_from']:                raise ValueError('End date cannot be before start date')        return vclass TransactionStatistics(BaseModel):    """    Статистика транзакций пользователя.    """    total_transactions: int = Field(0, ge=0, description="Общее количество транзакций")    total_deposited: Decimal = Field(Decimal('0.00'), ge=0, description="Общая сумма пополнений")    total_spent: Decimal = Field(Decimal('0.00'), ge=0, description="Общая сумма трат")    successful_transactions: int = Field(0, ge=0, description="Успешных транзакций")    failed_transactions: int = Field(0, ge=0, description="Неудачных транзакций")    average_transaction_amount: Decimal = Field(Decimal('0.00'), ge=0, description="Средняя сумма транзакции")    last_transaction_date: Optional[datetime] = Field(None, description="Дата последней транзакции")    @field_serializer('total_deposited', 'total_spent', 'average_transaction_amount')    def serialize_amounts(self, value: Decimal) -> str:        """Сериализация денежных сумм."""        return f"{value:.2f}"    @field_serializer('last_transaction_date')    def serialize_datetime(self, value: Optional[datetime]) -> Optional[str]:        return value.isoformat() if value else None